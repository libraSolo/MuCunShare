+++
date = '2024-8-24T16:21:57+08:00'
draft = false
title = '数据库_Redis'
author = '木村凉太'
categories = '数据库'
hiddenFromHomePage = true 
+++

# 数据库_Redis

# Redis

Redis 是一个开源的内存数据储存系统，它可以用于数据库、缓存和消息中间件。

## 优点

1. 高性能缓存
2. 数据持久化
3. 分布式缓存
4. 发布订阅消息系统

## 数据类型

* String
* Hash
* List
* Set
* Zset (有序集合)

新增

* BitMap
* HyperLogLog
* GEO
* Strean

## 过期时间

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/2736685315.jpg)

### 过期机制的思路

* 定时删除：计时器，到期删除。
* 延迟队列：使用一个延迟队列，从中取出来这个对象时，就已经过期，可以删除。
* 懒惰删除：每次使用时检查是否过期。
* 定期删除：每隔一段时间就遍历对象，找到过期并删除。

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/2132375535.jpg)

### QA:为什么不立刻删除？

理论上来说，并不是做不到，只不过代价比较高昂不值得而已。
最简单的做法就是使用定时器，但是定时器本身开销太大，还得考虑在更新过期时间的时候重置定时器。另外一种思路就是使用延迟队列，但是延迟队列本身开销也很大，修改过期时间也要调整延迟队列，还要引入大量的并发控制。
综合来看，并不值得。而定期删除和懒惰删除的策略虽然看上去可能浪费内存，但是这个浪费很少，并且对响应时间也没那么大的影响。

### QA: Redis 是怎么控制定期删除开销的？

在每一个定期删除循环中，Redis 会遍历 DB。如果这个 DB 完全没有设置了过期时间的 key，那就直接跳过。否则就针对这个 DB 抽一批 key，如果 key 已经过期，就直接删除。
如果在这一批 key 里面，过期的比例太低，那么就会中断循环，遍历下一个 DB。如果执行时间超过了阈值，也会中断。不过这个中断是整个中断，下一次定期删除的时候会从当前 DB 的下一个继续遍历。
总的来说，**Redis 是通过控制执行定期删除循环时间来控制开销** ，这样可以在服务正常请求和清理过期 key 之间取得平衡。

### QA: 如何控制定期删除的频率？

在 Redis 里面有一个参数叫做 hz，它代表的是 Redis 后台任务运行的频率。正常来说，这个值不需要调，即便调整也不要超过 100。

## 淘汰策略

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/4127343317.jpg)

### 为什么要淘汰

缓存满了，内存使用有上限。不能直接报错，所以要淘汰。

### LRU (最近最少使用算法)

只需要把  key  用额外的链表连起来，然后每次被访问到的key 都挪到队尾，那么队首就是最近最长时间未访问过的 key。

### LFU (最不经常使用算法)

实现的基本思路就是每次读写的时候，对象上面的次数都加 1，然后调整位置。

### 淘汰思路

* 先淘汰大对象： 数据太大，腾出内存。
* 先淘汰小对象：小对象，逻辑计算比较简单。
* 低热度优先
* 普通用户和 VIP，先淘汰普通用户

## 缓存模式

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/3997647587.jpg)

* Cache Aside (旁路缓存)
* Read/Write Through (读写穿透)
* Write Behind Caching (异步缓存写入)

### Cache Aside

Cache Aside 是最基本的缓存模式，在这个模式下，业务代码就是把缓存看成是和数据库一样的独立的数据源，然后业务代码控制怎么写入缓存，怎么写入数据库。一般来说，都是优先写入数据库的。

先写数据库是因为大多数业务场景下数据都是以数据库为准的，也就是说如果写入数据库成功了，就可以认为这个操作成功了。即便写入缓存失败，但是缓存本身会有过期时间，那么它过期之后重新加载，数据就会恢复一致。

**不管是先写数据库还是先写缓存，Cache Aside 都不能解决数据一致性问题。**

### Read Through

当缓存里面没有数据的时候，缓存会代替你去数据库里面把数据加载出来，并且缓存起来。

**不能解决数据一致性问题。**

### Write Through

当业务方写入数据的时候，只需要写入缓存。缓存会代替业务方去更新数据库。

**不能解决数据一致性问题。**

### Write Back

过期时间到了就写入数据库。

**可以解决解决数据一致性问题**

### 删除缓存

在更新数据的时候先更新数据库，然后将缓存删除。

**不能解决数据一致性问题。**

删除是最常用的更新缓存的模式，它是指在更新数据库之后，直接删除缓存。这种做法可以是业务代码来控制删除操作，也可以结合 Write Through 使用。而且删除缓存之后会使缓存命中率下降，也算是一个隐患。如果偶尔出现写频繁的场景，导致缓存一直被删除，那么就会使性能显著下降。缓存未命中回查数据库叠加写操作，数据库压力会很大。

删除缓存和别的模式一样，也有一致性问题。但是它的一致性问题是出在读线程缓存未命中和写线程冲突的情况下。

为了避免这种缓存不一致的问题，又有了延迟双删模式。

### 延迟双删

延迟双删类似于删除缓存的做法，它在第一次删除操作之后设定一个定时器，在一段时间之后再次执行删除。

第二次删除就是为了避开删除缓存中的读写导致数据不一致的场景。

## 高并发如何保证缓存一致性

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/3843790875.jpg)

### double-check 模式

它的基本思路可以总结为检查、加锁、检查，所以也叫做 double-check。double-check 经常用在使用读写锁的场景。

### 数据不一致的根源

* 操作部分失败
* 并发操作

### 解决方法

#### 版本号

增加版本号字段，每次更新就版本号+1，低等级版本号不能修改高版本数据。

#### 消息队列

增加个消息队列，然后就变得有序。

#### 分布式锁

通过加锁来打到一致性。

## 缓存问题：穿透、击穿、雪崩

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/3589049648.jpg)

### 缓存穿透

指**数据既不在缓存中，也不在数据库中** 。

#### 解决方案

* 回写特殊值：数据库找不到时，回写到缓存中一个特殊值。
* 布隆过滤器：业务代码过滤接口

### 缓存击穿

指**数据不在缓存中**，存在于数据库中。

#### 解决方案

singleflight 模式

### 雪崩

缓存里大量数据在同一时刻过期，导致请求都落到了数据库上。

#### 解决方案

设置不同过期时间。

要解决缓存雪崩，就是在数据批量加载到缓存的场景中在过期时间的基础上加 上一个随机量。比如说，我预计这一批数据的过期时间是 15 分钟。那么我就在设置每一条数据的过期时间的时候，在 15 分钟的基础上加上一个 0～180 秒的偏移量。那么这一批数据就不会在同一时刻过期，也就不存在缓存雪崩的问题 了。

### 限流

缓存穿透和击穿只有在高并发下才会成为一个问题，所以一个很自然的想法就是使用限流。限流可以考虑在两个地方使用：服务层面和数据库层面。

## Redis 单线程

### QA:为什么 Redis 是单线程的，但是又能做到高性能？

我们通常说的 Redis 单线程，其实是指处理命令的时候Redis是单线程的。但是 Redis 的其他部分，比如说持久化其实是另外的线程在处理。因此本质上，Redis 是多线程的。特别是 Redis 在 6.0 之后，连 IO 模型都改成了多线程的模型，进一步发挥了多核 CPU 的优势。

## 分布式锁

![请输入图片描述](http://mucunliangtai.com/usr/uploads/2024/09/264199379.jpg)

利用 Redis 来实现分布式锁的时候，所谓的锁就是一个普通的键值对。而加锁就是使用 SETNX 命令，排他地设置一个键值对。如果 SETNX 命令设置键值对成功了，那么说明加锁成功。如果没有设置成功，说明这个时候有人持有了锁，需要等待别人释放锁。而相应地，释放锁就是删除这个键值对。

### 等待时间

* 加锁失败可以设置轮询尝试每秒获取一次。
* 监听删除事件

### 过期时间

* 过期时间
* 续约，如果快过期，可以延长时间