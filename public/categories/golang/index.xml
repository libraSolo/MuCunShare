<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Golang - Category - 我的新Hugo网站</title>
        <link>http://localhost:1313/categories/golang/</link>
        <description>Golang - Category - 我的新Hugo网站</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 15 Aug 2024 16:21:57 &#43;0800</lastBuildDate><atom:link href="http://localhost:1313/categories/golang/" rel="self" type="application/rss+xml" /><item>
    <title>Go并发_基本并发原语_WaitGroup</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/</link>
    <pubDate>Thu, 15 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_waitgroup">Go并发_基本并发原语_WaitGroup</h1>
<h1 id="waitgroup-协同等待任务编排利器">WaitGroup (协同等待，任务编排利器)</h1>
<h2 id="方法">方法</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">delta</span> <span class="kt">int</span><span class="p">)</span> <span class="c1">// 用来设置 WaitGroup 的计数值</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Done</span><span class="p">()</span>         <span class="c1">// 用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1)</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span>         <span class="c1">// 调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0</span></span></span></code></pre></div></div><h2 id="基本使用">基本使用</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">WaitGroup</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则</span>
</span></span><span class="line"><span class="cl">    <span class="nx">noCopy</span> <span class="nx">noCopy</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 另外32bit是用作信号量的</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 总之，会找到对齐的那64bit作为state，其余的32bit做信号量</span>
</span></span><span class="line"><span class="cl">    <span class="nx">state1</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 得到state的地址和信号量的地址</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">wg</span> <span class="o">*</span><span class="nx">WaitGroup</span><span class="p">)</span> <span class="nf">state</span><span class="p">()</span> <span class="p">(</span><span class="nx">statep</span> <span class="o">*</span><span class="kt">uint64</span><span class="p">,</span> <span class="nx">semap</span> <span class="o">*</span><span class="kt">uint32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">))</span><span class="o">%</span><span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">)),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint64</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="o">&amp;</span><span class="nx">wg</span><span class="p">.</span><span class="nx">state1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><p>64 位环境下：waiter 数 | WaitGroup 的计数值 | 信号量
32 位环境下：信号量 | waiter 数 | WaitGroup 的计数值</p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_RWMutex</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/</link>
    <pubDate>Wed, 14 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_rwmutex">Go并发_基本并发原语_RWMutex</h1>
<h1 id="rwmutex">RWMutex</h1>
<p></p>
<p><strong>概念</strong>：RWMutex 在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。</p>
<p><strong>方法</strong>：</p>
<ul>
<li><strong>Lock/Unlock</strong>: 如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。</li>
<li><strong>RLock/Unlock</strong>：如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。</li>
<li><strong>Rlocker</strong>：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。</li>
<li><strong>TryRLock/TryLock</strong>: 尝试获取，同 Mutex。</li>
</ul>
<p>其他用法和注意和 Mutex 相似。</p>
<h2 id="常见问题">常见问题</h2>
<ol>
<li><strong>Read-preferring</strong>：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。</li>
<li><strong>Write-preferring</strong>：避免写饥饿，阻塞的是新来 reader， 让已经在工作的 reader 工作完成。</li>
<li><strong>不指定优先级</strong>：平等对待，解决饥饿。</li>
</ol>
<p><strong>Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。</strong></p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_Pool</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/</link>
    <pubDate>Tue, 13 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_pool">Go并发_基本并发原语_Pool</h1>
<h1 id="pool">Pool</h1>
<p></p>
<p>sync.Pool 用与缓存<strong>临时</strong>使用的对象，避免反复创建带来的性能损耗。所以如果没有别的对象引用，会被垃圾回收掉。</p>
<h2 id="特性">特性</h2>
<ol>
<li>sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象</li>
<li>sync.Pool 不可在使用之后再复制使用。</li>
</ol>
<h2 id="方法">方法</h2>
<p>New、Get 和 Put。</p>
<ol>
<li>New
Pool struct 包含一个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。</li>
<li>Get
从 Pool 取走一个元素，从 Pool 移除并返回。可能为 nil（Pool.New 字段没有设置，又没有空闲元素可以返回）。</li>
<li>Put
将一个元素提交个 Pool， 提交一个 nil 值，直接忽略。</li>
</ol>
<h2 id="原理">原理</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Pool</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">noCopy</span> <span class="nx">noCopy</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">local</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local fixed-size per-P pool, actual type is [P]poolLocal</span>
</span></span><span class="line"><span class="cl">	<span class="nx">localSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of the local array</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">victim</span>     <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// local from previous cycle</span>
</span></span><span class="line"><span class="cl">	<span class="nx">victimSize</span> <span class="kt">uintptr</span>        <span class="c1">// size of victims array</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">New</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><p>在 STW 时，victim 被清空，local 赋值给 victim，local 置为 nil，Get 取值的时候是从 victim 中获取。</p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_Once</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/</link>
    <pubDate>Mon, 12 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_once">Go并发_基本并发原语_Once</h1>
<h1 id="once">Once</h1>
<p></p>
<p>Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。</p>
<h2 id="方法">方法</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">o</span> <span class="o">*</span><span class="nx">Once</span><span class="p">)</span> <span class="nf">Do</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">())</span></span></span></code></pre></div></div><p>可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。</p>
<h2 id="常见错误-罕见">常见错误 （罕见）</h2>
<h3 id="1-死锁">1. 死锁</h3>
<p>Do 方法会执行一次 f，但是如果 f 中再次调用这个 Once 的 Do 方法的话，就会导致死锁的情况出现。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">once</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Once</span>
</span></span><span class="line"><span class="cl">    <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">once</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;初始化&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">})</span>
</span></span><span class="line"><span class="cl">    <span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><h3 id="2未初始化">2.未初始化</h3>
<p>如果执行 f 的时候 panic，未初始化成功，但是 Once 依旧认为执行成功，不会再次执行 f。</p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_Mutex</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/</link>
    <pubDate>Sun, 11 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_mutex">Go并发_基本并发原语_Mutex</h1>
<h1 id="mutex-互斥锁排他锁">Mutex (互斥锁/排他锁)</h1>
<p></p>
<p><strong>临界区</strong> ： 在并发编程中，如果程序中的一部分会被并发访问或修改，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。</p>
<p><strong>适用场景</strong> ：</p>
<ol>
<li>共享资源</li>
<li>任务编排</li>
<li>消息传递</li>
</ol>
<p><strong>检测工具</strong>：Go race detector (在运行时，触发才可以检测)</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="err">$</span> <span class="k">go</span> <span class="nx">test</span> <span class="o">-</span><span class="nx">race</span> <span class="nx">mypkg</span>    <span class="c1">// test the package</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="k">go</span> <span class="nx">run</span> <span class="o">-</span><span class="nx">race</span> <span class="nx">mysrc</span><span class="p">.</span><span class="k">go</span>  <span class="c1">// compile and run the program</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="k">go</span> <span class="nx">build</span> <span class="o">-</span><span class="nx">race</span> <span class="nx">mycmd</span>   <span class="c1">// build the command</span>
</span></span><span class="line"><span class="cl"><span class="err">$</span> <span class="k">go</span> <span class="nx">install</span> <span class="o">-</span><span class="nx">race</span> <span class="nx">mypkg</span> <span class="c1">// install the package</span></span></span></code></pre></div></div><h2 id="mutex-的基本使用">Mutex 的基本使用</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"> <span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl"> <span class="nx">sema</span> <span class="kt">uint32</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// state 字段被分为 4 部分</span>
</span></span><span class="line"><span class="cl"><span class="kd">const</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutexLocked</span>           <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="kc">iota</span> <span class="c1">// 持有锁的标记</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutexWoken</span>                        <span class="c1">// 唤醒标记</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutexStarving</span>                     <span class="c1">// 饥饿标记</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mutexWaiterShift</span>      <span class="p">=</span> <span class="kc">iota</span>      <span class="c1">// 阻塞等待的 waiter 数量,其最大为 2^(32-3)-1</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span></span></span></code></pre></div></div><p>方法：</p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_Context</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/</link>
    <pubDate>Sat, 10 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_context">Go并发_基本并发原语_Context</h1>
<h1 id="context">Context</h1>
<p>上下文联系。</p>
<p></p>
<h2 id="使用场景">使用场景</h2>
<ol>
<li>上下文信息传递 （request-scoped），比如处理 http 请求、在请求处理链路上传递信息</li>
<li>控制子 goroutine 的运行</li>
<li>超时控制调用</li>
<li>取消的方法调用</li>
</ol>
<h2 id="基本使用">基本使用</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Deadline</span><span class="p">()</span> <span class="p">(</span><span class="nx">deadline</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span><span class="p">,</span> <span class="nx">ok</span> <span class="kt">bool</span><span class="p">)</span> <span class="c1">// 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期，ok 的值是 false。</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Done</span><span class="p">()</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>                   <span class="c1">// 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Err</span><span class="p">()</span> <span class="kt">error</span>                              <span class="c1">//</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Value</span><span class="p">(</span><span class="nx">key</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kd">interface</span><span class="p">{}</span>       <span class="c1">// 返回此 ctx 中和指定的 key 相关联的 value。</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div><h3 id="生成顶层-context-的方法">生成顶层 Context 的方法、</h3>
<ul>
<li>context.Background()：返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。</li>
<li>context.TODO()：Background() 的别名，不知道用啥或者不知道什么上下文用这个。</li>
</ul>
<h3 id="默认原则">默认原则</h3>
<ol>
<li>一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。</li>
<li>从来不把 nil 当做 Context 类型的参数值，可以用 context.TODO()。</li>
<li>Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。</li>
<li><strong>key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是自己定义的类型。</strong></li>
<li>常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。</li>
</ol>
<h3 id="withvalue">WithValue</h3>
<p>它持有一个 key-value 键值对，还持有 parent 的 Context。它覆盖了 Value 方法，优先从自己的存储中检查这个 key，不存在的话会从 parent 中继续检查，链式查找。</p>]]></description>
</item>
<item>
    <title>Go并发_基本并发原语_Cond</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/</link>
    <pubDate>Fri, 09 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/</guid>
    <description><![CDATA[<h1 id="go并发_基本并发原语_cond">Go并发_基本并发原语_Cond</h1>
<h1 id="cond">Cond</h1>
<p></p>
<p><strong>目的</strong>：为等待 / 通知场景下的并发问题提供支持。</p>
<h2 id="基本用法">基本用法</h2>
<p>Cond 并发原语初始化的时候，需要关联一个 Locker 接口的实例，一般我们使用 Mutex 或者 RWMutex。</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Cond</span>
</span></span><span class="line"><span class="cl">  <span class="kd">func</span> <span class="nf">NeWCond</span><span class="p">(</span><span class="nx">l</span> <span class="nx">Locker</span><span class="p">)</span> <span class="o">*</span><span class="nx">Cond</span>
</span></span><span class="line"><span class="cl">  <span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Broadcast</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Signal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cond</span><span class="p">)</span> <span class="nf">Wait</span><span class="p">()</span></span></span></code></pre></div></div><p><strong>Signal 方法</strong>：允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。</p>
<p><strong>Broadcast 方法</strong>：允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。</p>]]></description>
</item>
<item>
    <title>Go并发_原子操作_atomic</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/</link>
    <pubDate>Thu, 08 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/</guid>
    <description><![CDATA[<h1 id="go并发_原子操作_atomic">Go并发_原子操作_atomic</h1>
<h1 id="原子操作">原子操作</h1>
<p></p>
<p>原子操作是指在并发编程中，某个操作要么完全执行，要么完全不执行，不会被其他线程或任务打断。这种特性确保了在多线程环境下的操作的完整性和一致性。</p>
<h2 id="方法">方法</h2>
<h3 id="add">Add</h3>
<p><code>func AddInt32(addr *int32, delta int32) (new int32)</code></p>
<p>可以加一个负数， 对于无符号的整数来说，可以利用补码规则，由减法变加法。</p>
<h3 id="cascompareandswap">CAS（CompareAndSwap）</h3>
<p><code>func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</code></p>
<p>比较当前 addr 地址里的值是不是 old，如果不等于 old，就返回 false；如果等于 old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。</p>
<h3 id="swap">Swap</h3>
<p><code>func SwapInt32(addr *int32, new int32) (old int32)</code></p>
<p>不需要比较相等，直接替换。</p>
<h3 id="load">Load</h3>
<p>Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。</p>
<h3 id="store">Store</h3>
<p>Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。</p>]]></description>
</item>
<item>
    <title>Go并发_扩展</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/</link>
    <pubDate>Wed, 07 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/</guid>
    <description><![CDATA[<h1 id="go并发_扩展">Go并发_扩展</h1>
<h1 id="singleflight">SingleFlight</h1>
<p>多个 Goroutine 同时调用一个函数，只会让一个调用，并把结果返回给所有的调用者。</p>
<p>**使用互斥锁和 Map 来实现的。</p>
<h2 id="和-synconce-的区别">和 sync.Once 的区别</h2>
<p>sync.Once 主要用于单次的初始化，而 SingleFlight 主要用在合并并发请求的场景中。</p>
<h1 id="cyclicbarrier">CyclicBarrier</h1>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">parties</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">CyclicBarrier</span> <span class="c1">// 它只需要一个参数，来指定循环栅栏参与者的数量；</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewWithAction</span><span class="p">(</span><span class="nx">parties</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">barrierAction</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span> <span class="nx">CyclicBarrier</span> <span class="c1">// 它额外提供一个函数，可以在每一次到达执行点的时候执行一次。具体的时间点是在最后一个参与者到达之后，但是其它的参与者还未被放行之前。我们可以利用它，做放行之前的一些共享状态的更新等操作。</span></span></span></code></pre></div></div><p>举例成产 H2O</p>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">water</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;context&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;github.com/marusama/cyclicbarrier&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;golang.org/x/sync/semaphore&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;math/rand&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sort&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;sync&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;testing&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义水分子合成的辅助数据结构</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">H2O</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">semaH</span> <span class="o">*</span><span class="nx">semaphore</span><span class="p">.</span><span class="nx">Weighted</span>         <span class="c1">// 氢原子的信号量</span>
</span></span><span class="line"><span class="cl">	<span class="nx">semaO</span> <span class="o">*</span><span class="nx">semaphore</span><span class="p">.</span><span class="nx">Weighted</span>         <span class="c1">// 氧原子的信号量</span>
</span></span><span class="line"><span class="cl">	<span class="nx">b</span>     <span class="nx">cyclicbarrier</span><span class="p">.</span><span class="nx">CyclicBarrier</span> <span class="c1">// 循环栅栏，用来控制合成</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">New</span><span class="p">()</span> <span class="o">*</span><span class="nx">H2O</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">H2O</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">semaH</span><span class="p">:</span> <span class="nx">semaphore</span><span class="p">.</span><span class="nf">NewWeighted</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="c1">//氢原子需要两个</span>
</span></span><span class="line"><span class="cl">		<span class="nx">semaO</span><span class="p">:</span> <span class="nx">semaphore</span><span class="p">.</span><span class="nf">NewWeighted</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="c1">// 氧原子需要一个</span>
</span></span><span class="line"><span class="cl">		<span class="nx">b</span><span class="p">:</span>     <span class="nx">cyclicbarrier</span><span class="p">.</span><span class="nf">New</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>     <span class="c1">// 需要三个原子才能合成</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h2o</span> <span class="o">*</span><span class="nx">H2O</span><span class="p">)</span> <span class="nf">hydrogen</span><span class="p">(</span><span class="nx">releaseHydrogen</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">semaH</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">releaseHydrogen</span><span class="p">()</span>                 <span class="c1">// 输出H</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">Await</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span> <span class="c1">//等待栅栏放行</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">semaH</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>              <span class="c1">// 释放氢原子空槽</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">h2o</span> <span class="o">*</span><span class="nx">H2O</span><span class="p">)</span> <span class="nf">oxygen</span><span class="p">(</span><span class="nx">releaseOxygen</span> <span class="kd">func</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">semaO</span><span class="p">.</span><span class="nf">Acquire</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">releaseOxygen</span><span class="p">()</span>                   <span class="c1">// 输出O</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nf">Await</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nf">Background</span><span class="p">())</span> <span class="c1">//等待栅栏放行</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span><span class="p">.</span><span class="nx">semaO</span><span class="p">.</span><span class="nf">Release</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>              <span class="c1">// 释放氢原子空槽</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 单元测试</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">TestWaterFactory</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">testing</span><span class="p">.</span><span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">//用来存放水分子结果的channel</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">ch</span> <span class="kd">chan</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">	<span class="nx">releaseHydrogen</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;H&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">releaseOxygen</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ch</span> <span class="o">&lt;-</span> <span class="s">&#34;O&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 300个原子，300个goroutine,每个goroutine并发的产生一个原子</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">N</span> <span class="p">=</span> <span class="mi">100</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">N</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">h2o</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 用来等待所有的goroutine完成</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">wg</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="nx">N</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 200个氢原子goroutine</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="o">*</span><span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">h2o</span><span class="p">.</span><span class="nf">hydrogen</span><span class="p">(</span><span class="nx">releaseHydrogen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 100个氧原子goroutine</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Duration</span><span class="p">(</span><span class="nx">rand</span><span class="p">.</span><span class="nf">Intn</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">h2o</span><span class="p">.</span><span class="nf">oxygen</span><span class="p">(</span><span class="nx">releaseOxygen</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">//等待所有的goroutine执行完</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 结果中肯定是300个原子</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">N</span><span class="o">*</span><span class="mi">3</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;expect %d atom but got %d&#34;</span><span class="p">,</span> <span class="nx">N</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 每三个原子一组，分别进行检查。要求这一组原子中必须包含两个氢原子和一个氧原子，这样才能正确组成一个水分子。</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">s</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">string</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">=</span> <span class="o">&lt;-</span><span class="nx">ch</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sort</span><span class="p">.</span><span class="nf">Strings</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">water</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">water</span> <span class="o">!=</span> <span class="s">&#34;HHO&#34;</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">t</span><span class="p">.</span><span class="nf">Fatalf</span><span class="p">(</span><span class="s">&#34;expect a water molecule but got %s&#34;</span><span class="p">,</span> <span class="nx">water</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div></div>]]></description>
</item>
<item>
    <title>Go并发_分组操作</title>
    <link>http://localhost:1313/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/</link>
    <pubDate>Tue, 06 Aug 2024 16:21:57 &#43;0800</pubDate>
    <author>木村凉太</author>
    <guid>http://localhost:1313/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/</guid>
    <description><![CDATA[<h1 id="go并发_分组操作">Go并发_分组操作</h1>
<h1 id="分组操作">分组操作</h1>
<p>分组执行一批相同或类似的任务。</p>
<h1 id="errgroup">ErrGroup</h1>
<p>大任务拆成几个小任务并发执行</p>
<h2 id="withcontext">WithContext</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">WithContext</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">Group</span><span class="p">,</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span></span></span></code></pre></div></div><p>这个方法返回一个 Group 实例，同时还会返回一个使用 context.WithCancel(ctx) 生成的新 Context。一旦有一个子任务返回错误，或者是 Wait 调用返回，这个新 Context 就会被 cancel。</p>
<p>如果传递给 WithContext 的 ctx 参数，是一个可以 cancel 的 Context 的话，那么，它被 cancel 的时候，并不会终止正在执行的子任务。(可以由子任务终止，向上传递)</p>
<h2 id="go">Go</h2>
<div class="code-block code-line-numbers open" style="counter-reset: code-block 0">
    <div class="code-header language-bash">
        <span class="code-title"><i class="arrow fas fa-chevron-right fa-fw" aria-hidden="true"></i></span>
        <span class="ellipses"><i class="fas fa-ellipsis-h fa-fw" aria-hidden="true"></i></span>
        <span class="copy" title="Copy to clipboard"><i class="far fa-copy fa-fw" aria-hidden="true"></i></span>
    </div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">g</span> <span class="o">*</span><span class="nx">Group</span><span class="p">)</span> <span class="nf">Go</span><span class="p">(</span><span class="nx">f</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">error</span><span class="p">)</span></span></span></code></pre></div></div><p>任务成功返回 nil，否则返回 error，并且会 cancel 那个新的 Context。</p>]]></description>
</item>
</channel>
</rss>
