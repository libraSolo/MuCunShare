[{"categories":["笔记"],"content":"浅析 Git 和 SVN 浅析 Git 和 SVN ","date":"2024-09-03","objectID":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/:0:0","tags":null,"title":"浅析 Git 和 SVN","uri":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/"},{"categories":["笔记"],"content":"Git vs SVN Git 是分布式 ( 可以离线工作) ， SVN 是集中式 ( 需要联网工作 ) 。 Git 有本地分支且 Git 分支是 ‘ 指针指向某次提交 ’ ( 分支廉价 ) SVN 无本地分支且 SVN 分支是 ‘ 拷贝的目录 ’ ( 分支昂贵 ) ","date":"2024-09-03","objectID":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/:1:0","tags":null,"title":"浅析 Git 和 SVN","uri":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/"},{"categories":["笔记"],"content":"SVN 核心思维 SVN = 版本控制 + 备份服务器 SVN 是集中版本控制工具，多用户共享同一资源，并且可以对资源进行修改和更新。Repository 收到用户 commit 时，会记录更改资源的人和版本的更新，所以可以恢复到之前记录的修改点 ( 回滚版本 ) ","date":"2024-09-03","objectID":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/:2:0","tags":null,"title":"浅析 Git 和 SVN","uri":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/"},{"categories":["笔记"],"content":"SVN 操作流程 Checkout : Checkout 是 Workspace 的初始化，通常是根目录递归 checkout Rule : 一个 Workspace 原则 Update update 的对象是本地的 Workspace。服务器上有了更新的代码，或者本地缺失、损害，可以 update 可以自动判断并更新( 最新版 ) Commit commit 的对象是整个 Repository。当本地修改后，尽快修改服务器代码，对团队影响很大 Rule : 完整 Issue 提交原则 Rule : 提交前无 bug 原则 Rule : 多用户协调逻辑提前确认原则 Rule : 提交完整文档原则 Rule : 提交添加日志原则 锁定 - 修改 - 解锁 一定时间内 Repository 的一个文件仅允许一个人修改，直到解锁。 锁定 **Get lock **，解锁 Release lock ","date":"2024-09-03","objectID":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/:2:1","tags":null,"title":"浅析 Git 和 SVN","uri":"/%E6%B5%85%E6%9E%90-git-%E5%92%8C-svn/"},{"categories":["数据库"],"content":"数据库_Redis Redis Redis 是一个开源的内存数据储存系统，它可以用于数据库、缓存和消息中间件。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:0:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"优点 高性能缓存 数据持久化 分布式缓存 发布订阅消息系统 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:1:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"数据类型 String Hash List Set Zset (有序集合) 新增 BitMap HyperLogLog GEO Strean ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:2:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"过期时间 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:3:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"过期机制的思路 定时删除：计时器，到期删除。 延迟队列：使用一个延迟队列，从中取出来这个对象时，就已经过期，可以删除。 懒惰删除：每次使用时检查是否过期。 定期删除：每隔一段时间就遍历对象，找到过期并删除。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:3:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"QA:为什么不立刻删除？ 理论上来说，并不是做不到，只不过代价比较高昂不值得而已。 最简单的做法就是使用定时器，但是定时器本身开销太大，还得考虑在更新过期时间的时候重置定时器。另外一种思路就是使用延迟队列，但是延迟队列本身开销也很大，修改过期时间也要调整延迟队列，还要引入大量的并发控制。 综合来看，并不值得。而定期删除和懒惰删除的策略虽然看上去可能浪费内存，但是这个浪费很少，并且对响应时间也没那么大的影响。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:3:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"QA: Redis 是怎么控制定期删除开销的？ 在每一个定期删除循环中，Redis 会遍历 DB。如果这个 DB 完全没有设置了过期时间的 key，那就直接跳过。否则就针对这个 DB 抽一批 key，如果 key 已经过期，就直接删除。 如果在这一批 key 里面，过期的比例太低，那么就会中断循环，遍历下一个 DB。如果执行时间超过了阈值，也会中断。不过这个中断是整个中断，下一次定期删除的时候会从当前 DB 的下一个继续遍历。 总的来说，Redis 是通过控制执行定期删除循环时间来控制开销 ，这样可以在服务正常请求和清理过期 key 之间取得平衡。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:3:3","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"QA: 如何控制定期删除的频率？ 在 Redis 里面有一个参数叫做 hz，它代表的是 Redis 后台任务运行的频率。正常来说，这个值不需要调，即便调整也不要超过 100。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:3:4","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"淘汰策略 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:4:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"为什么要淘汰 缓存满了，内存使用有上限。不能直接报错，所以要淘汰。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:4:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"LRU (最近最少使用算法) 只需要把 key 用额外的链表连起来，然后每次被访问到的key 都挪到队尾，那么队首就是最近最长时间未访问过的 key。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:4:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"LFU (最不经常使用算法) 实现的基本思路就是每次读写的时候，对象上面的次数都加 1，然后调整位置。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:4:3","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"淘汰思路 先淘汰大对象： 数据太大，腾出内存。 先淘汰小对象：小对象，逻辑计算比较简单。 低热度优先 普通用户和 VIP，先淘汰普通用户 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:4:4","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"缓存模式 Cache Aside (旁路缓存) Read/Write Through (读写穿透) Write Behind Caching (异步缓存写入) ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"Cache Aside Cache Aside 是最基本的缓存模式，在这个模式下，业务代码就是把缓存看成是和数据库一样的独立的数据源，然后业务代码控制怎么写入缓存，怎么写入数据库。一般来说，都是优先写入数据库的。 先写数据库是因为大多数业务场景下数据都是以数据库为准的，也就是说如果写入数据库成功了，就可以认为这个操作成功了。即便写入缓存失败，但是缓存本身会有过期时间，那么它过期之后重新加载，数据就会恢复一致。 不管是先写数据库还是先写缓存，Cache Aside 都不能解决数据一致性问题。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"Read Through 当缓存里面没有数据的时候，缓存会代替你去数据库里面把数据加载出来，并且缓存起来。 不能解决数据一致性问题。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"Write Through 当业务方写入数据的时候，只需要写入缓存。缓存会代替业务方去更新数据库。 不能解决数据一致性问题。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:3","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"Write Back 过期时间到了就写入数据库。 可以解决解决数据一致性问题 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:4","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"删除缓存 在更新数据的时候先更新数据库，然后将缓存删除。 不能解决数据一致性问题。 删除是最常用的更新缓存的模式，它是指在更新数据库之后，直接删除缓存。这种做法可以是业务代码来控制删除操作，也可以结合 Write Through 使用。而且删除缓存之后会使缓存命中率下降，也算是一个隐患。如果偶尔出现写频繁的场景，导致缓存一直被删除，那么就会使性能显著下降。缓存未命中回查数据库叠加写操作，数据库压力会很大。 删除缓存和别的模式一样，也有一致性问题。但是它的一致性问题是出在读线程缓存未命中和写线程冲突的情况下。 为了避免这种缓存不一致的问题，又有了延迟双删模式。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:5","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"延迟双删 延迟双删类似于删除缓存的做法，它在第一次删除操作之后设定一个定时器，在一段时间之后再次执行删除。 第二次删除就是为了避开删除缓存中的读写导致数据不一致的场景。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:5:6","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"高并发如何保证缓存一致性 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:6:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"double-check 模式 它的基本思路可以总结为检查、加锁、检查，所以也叫做 double-check。double-check 经常用在使用读写锁的场景。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:6:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"数据不一致的根源 操作部分失败 并发操作 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:6:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"解决方法 版本号 增加版本号字段，每次更新就版本号+1，低等级版本号不能修改高版本数据。 消息队列 增加个消息队列，然后就变得有序。 分布式锁 通过加锁来打到一致性。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:6:3","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"缓存问题：穿透、击穿、雪崩 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:7:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"缓存穿透 指数据既不在缓存中，也不在数据库中 。 解决方案 回写特殊值：数据库找不到时，回写到缓存中一个特殊值。 布隆过滤器：业务代码过滤接口 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:7:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"缓存击穿 指数据不在缓存中，存在于数据库中。 解决方案 singleflight 模式 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:7:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"雪崩 缓存里大量数据在同一时刻过期，导致请求都落到了数据库上。 解决方案 设置不同过期时间。 要解决缓存雪崩，就是在数据批量加载到缓存的场景中在过期时间的基础上加 上一个随机量。比如说，我预计这一批数据的过期时间是 15 分钟。那么我就在设置每一条数据的过期时间的时候，在 15 分钟的基础上加上一个 0～180 秒的偏移量。那么这一批数据就不会在同一时刻过期，也就不存在缓存雪崩的问题 了。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:7:3","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"限流 缓存穿透和击穿只有在高并发下才会成为一个问题，所以一个很自然的想法就是使用限流。限流可以考虑在两个地方使用：服务层面和数据库层面。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:7:4","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"Redis 单线程 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:8:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"QA:为什么 Redis 是单线程的，但是又能做到高性能？ 我们通常说的 Redis 单线程，其实是指处理命令的时候Redis是单线程的。但是 Redis 的其他部分，比如说持久化其实是另外的线程在处理。因此本质上，Redis 是多线程的。特别是 Redis 在 6.0 之后，连 IO 模型都改成了多线程的模型，进一步发挥了多核 CPU 的优势。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:8:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"分布式锁 利用 Redis 来实现分布式锁的时候，所谓的锁就是一个普通的键值对。而加锁就是使用 SETNX 命令，排他地设置一个键值对。如果 SETNX 命令设置键值对成功了，那么说明加锁成功。如果没有设置成功，说明这个时候有人持有了锁，需要等待别人释放锁。而相应地，释放锁就是删除这个键值对。 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:9:0","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"等待时间 加锁失败可以设置轮询尝试每秒获取一次。 监听删除事件 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:9:1","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"过期时间 过期时间 续约，如果快过期，可以延长时间 ","date":"2024-09-02","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/:9:2","tags":null,"title":"数据库_Redis","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_redis/"},{"categories":["数据库"],"content":"数据库_MySQL 索引 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"索引的分类 按照索引结构 B 树索引 使用 B / B+ 树结构，高效的查找、插入和删除。 适用于范围查询。 哈希索引 使用哈希表实现，查找速度很快，不支持范围查询。 适用于查找特定的值。 位图索引 使用位图表示数据，适用于不同值较少的列 适用于大规模查询。 按照索引的使用方式 主键索引 基于表的主键创建的索引，自动创建，确保主键唯一性。 唯一索引 确保索引列中的值唯一，不能包含重复值。 可以用于非主键列。 普通索引 没有唯一性，可以包含重复值。 增加查询速度，不保证唯一性。 复合索引 由多个列组成的索引，支持多列查询。 提高查询的复杂性。 前缀索引 包含某个列的前一部分。 适用于储存字符/字节的列。 覆盖索引 某个索引包含某个查询的所有列。 按照储存方式 聚集索引 数据存储顺序与索引顺序相同，表中的数据行按照索引的顺序排列。 每个表只能有一个聚集索引，因为数据行只能按一种方式存储。 非聚集索引 索引与数据存储分开，索引包含指向数据行的指针。 一个表可以有多个非聚集索引。 特殊类型 全文索引 专门用于文本搜索，支持对文本数据进行复杂查询。 常用于搜索引擎和内容管理系统。 空间索引 用于地理信息系统（GIS）中的空间数据查询。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"索引的代价 索引本身需要存储起来，消耗磁盘空间。 运行时，索引会加载到内存中，消耗内存空间。 增删改的时候，同步维护索引，引入额外的消耗。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:2:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"B+ 树的优势 B+ 树的高度更低，所以查询耗时更少，性能更好。 B+ 树的叶子节点被串联起来了，更适合范围查询。 B+ 树的非叶子节点没有存放数据，所以可以放在内存中，查询性能更好。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:3:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:数据库索引为什么用 B+ 树 与 B+ 树相比，平衡二叉树、红黑树在同等数据量下，高度更高，性能更差，而且它们会频繁执行再平衡过程，来保证树形结构平衡。 与 B+ 树相比，跳表在极端情况下会退化为链表，平衡性差 ，而数据库查询需要一个可预期的查询时间，并且跳表需要更多的内存。 与 B+ 树相比，B 树的数据存储在全部节点中，对范围查询不友好 。非叶子节点存储了数据，导致内存中难以放下全部非叶子节点 。如果内存放不下非叶子节点，那么就意味着查询非叶子节点的时候都需要磁盘 IO。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:4:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:为什么数据库不使用索引 可能的原因： 使用了 !=、Like 之类的查询 字段区分不大 使用了特殊的表达式，包括数学运算和函数调用。 数据量太小 有一种说法是含有 NULL 的列上的索引会失效，不过这个说法并不准确，实际上 MySQL 还是会尽可能用索引的。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:5:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:索引与 NULL 的特殊之处 NULL 通常表示 不知道、不存在、不合法等语义。 MySQL 会尽可能使用索引，即使有零值，并且 is null 和 is not null 都可以使用索引。 其次 MySQL 的唯一索引允许有多行的值都是 NULL。也就是说你可以有很多行唯一索引的列的值都是 NULL。但是不管怎么说，使用 NULL 都是一个比较差的实践。 SQL 优化 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:6:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"explain explain + sql语句 type ：指的是查询到所需行的方式，从好到坏依次是 system \u003e const \u003e eq_ref \u003e ref \u003e range \u003e index \u003e ALL。 possible_keys：候选索引。 key：实际用的索引。 rows：扫描的行数。 filtered：所需数据占 rows 的比例。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:7:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"优化 覆盖索引：将 where 判断的，或者查询要使用的列A,B可以组合索引。 order by：将排序加入索引(索引本身就是有序的)。 count：估计值取代精确值，额外表或者 Redis 记录总数。 分布式事务不一致的话，如果短时间内业务可以接受，可以通过异步刷新 redis 的数量，也可以用 Canal 之类的工具监听 MySQL binlog 来刷新总数。 索引提示：使用指定索引。FORCE INDEX、USE INDEX 和 IGNORE INDEX。 where 替换 having：一般来说，数据库都是先根据 WHERE 条件找到候选的列，再根据 HAVING 条件进行二次过滤。 可以提前过滤减少查询时间。 数据库锁 在 MySQL 的 InnoDB 引擎里面，锁是借助索引来实现的。或者说，加锁锁住的其实是索引项，更加具体地来说，就是锁住了叶子节点 。 锁的释放时机：只有在执行 Rollback 或者 Commit 的时候，锁才会被释放掉。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:8:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"锁的类型 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"乐观锁和悲观锁 乐观锁是直到要修改数据的时候，才检测数据是否已经被别人修改过。 悲观锁是在初始时刻就直接加锁保护好临界资源 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:1","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"行锁与表锁 行锁：锁住一行或者多行。(借助索引来实现的，如果没有命中任何索引，则只能使用表锁) 表锁：锁住整个表。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:2","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"共享锁和排他锁 共享锁是指一个线程加锁之后，其他线程还是可以继续加同类型的锁。 排它锁是指一个线程加锁之后，其他线程就不能再加锁了。 可以理解为 读写锁，读(共享)，写(排他)。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:3","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"意向锁 意向锁相当于一个信号，就是告诉别人我要加锁了，所以意向锁并不是一个真正物理意义上的锁。 它能和排他锁结合，意向共享锁和意向排他锁。 使用意向锁能够 提高数据库的并发性能，并且避免死锁问题。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:4","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"记录锁、间隙锁和临键锁 记录锁：锁住了特定的某一条记录的锁。 间隙锁：锁住了某一段记录的锁。（左开右开） 记录锁和记录锁是排它的，但是间隙锁和间隙锁不是排它的 。 临键锁：记录锁 + 间隙锁。临键锁不仅仅是会用记录锁锁住命中的记录，也会用间隙锁锁住记录之间的空隙 。（左开右闭） ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:9:5","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:介绍一下 MySQL 锁 MySQL 里面的锁机制特别丰富，这里我以 InnoDB 引擎为例。首先，从锁的范围来看，可以分成行锁和表锁。其次，从排它性来看，可以分成排它锁和共享锁。还有意向锁，结合排它性，就分为排它意向锁和共享意向锁。还有三个重要的锁概念，记录锁、间隙锁和临键锁。记录锁，是指锁住某条记录；间隙锁，是指锁住两条记录之间的位置；临键锁可以看成是记录锁与间隙锁的组合情况。 还有一种分类方法，是乐观锁和悲观锁。那么在数据库里面使用乐观锁，本质上是一种应用层面的 CAS 操作。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:10:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:临键锁引发的死锁 当两个线程插入两个不存在的 id 时，线程都会产生 (id,supremum] 的临键锁，这个时候就会产生死锁问题，同时等待对方释放掉持有的间隙锁。 解决方案 不管数据如何，直接插入一个默认数据，插入成功则是不存在，插入失败则是存在，所以不会使用间隙锁，使用了行锁。 调整数据库的隔离级别，降低为已提交读，就没有间隙锁了。 放弃悲观锁，使用乐观锁。CAS 原子操作。 MVCC 协议 避免读写阻塞延申出 MVCC 协议。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:11:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"隔离级别(从低到高) 读未提交：是指一个事务可以看到另外一个事务尚未提交的修改。 读已提交：是指一个事务只能看到已经提交的事务的修改。 这意味着如果在事务执行过程中有别的事务提交了，那么事务还是能够看到别的事务最新 提交的修改。 可重复读：是指在这一个事务内部读同一个数据多次，读到的结果都是同一个。这意味着即便在事务执行过程中有别的事务提交，这个事务依旧看不到别的事务提交的修改 。这是 MySQL 默认的隔离级别。 串行化：是指事务对数据的读写都是串行化的。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:12:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"异常 脏读：读到了别的事务还没有提交的数据。之所以叫做“脏”读，就是因为未提交数据可能会被回滚掉。 不可重复读：一个事务执行过程中，对同一行数据读到的结果不同。 幻读：事务执行过程中，别的事务插入了新的数据并且提交了，然后事务在后续步骤中读到了这个新的数据。 理论上来说可重复读是没有解决幻读的 。但是 MySQL 因为使用了临键锁，因此它的可重复读隔离级别已经解决了幻读问题。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:13:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"快照读和当前读 快照读就是在事务开始的时候创建 了一个数据的快照，在整个事务过程中都读这个快照 当前读，则是每次都去读最新数 据。MySQL 在可重复读这个隔离级别下，查询的执行效果和快照读非常接近。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:14:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"Read View Read View 只能用于 读已提交和可重复读。 读已提交：每次发起查询都会创建一个新的 Read View。 可重复读：事务开始时，创建 Read View。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:15:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"QA:什么是 MCCC ? MVCC 是 MySQL InnoDB 引擎用于控制数据并发访问的协议。MV 借助于版本链来实现的。在 InnoDB 引擎里面，每一行都有两个额外的列，一 个是 trx_id，代表的是修改这一行数据的事务 ID。另外一个是 r 的是回滚指针。InnoDB 引擎通过回滚指针，将数据的不同版本串联在一起， 也就是版本链。这些串联起来的历史版本，被放到了 undolog 里面。当某一个 事务发起查询的时候，MVCC 会根据事务的隔离级别来生成不同的 Read View，从而控制事务查询最终得到的结果。 数据库事务 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:16:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"undo log(回滚日志) 记录日志，相反操作来恢复数据库 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:17:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"redo log(操作日志) innoDB 引擎写数据时先修改内存的数据同时写redo log，然后刷磁盘。如果此时G了，可以通过 redo log来写入。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:18:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"ACID 事务的 ACID 特性是指原子性（Atomicity）、一致性 （Consistency）、隔离性 （Isolation）还有持久性（Durability）。 原子性：事务是一个不可分割的整体，它在执行过程中不能被中断或推迟，它的所有操作 都必须一次性执行，要么都成功，要么都失败。 一致性：事务执行的结果必须满足数据约束条件，不会出现矛盾的结果。注意这里的一致 性和我们讨论的分布式环境下的一致性语义有所差别，后者强调的是不同数据源之间数据 一致。 隔离性：事务在执行的时候可以隔离其他事务的干扰，也就是不同事务之间不会相互影 响。 持久性：事务执行的结果必须保证在数据库里永久保存，即使系统出现故障或者数据库被 删除，事务的结果也不会丢失。 主键生成算法 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:19:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"UUID ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:20:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"弊端 过长 UUID 不是递增的 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:20:1","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"页分裂 UUID 最大的缺陷是它产生的 ID 不是递增的。一般来说，我们倾向于在数据库中使用自增主键，因为这样可以迫使数据库的树朝着一个方向增长，而不会造成中间叶节点分裂，这样插入性能最好。而整体上 UUID 生成的 ID 可以看作是随机，那么就会导致数据往页中间插入，引起更加频繁地页分裂，在糟糕的情况下，这种分裂可能引起连锁反应，整棵树的树形结构都会受到影响。所以我们普遍倾向于采用递增的主键。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:20:2","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"顺序读 自增主键还有一个好处，就是数据会有更大的概率按照主键的大小排序，两条主键相近的记录，在磁盘上位置也是相近的。那么可以预计，在范围查询的时候，我们能够更加充分地利用到磁盘的顺序读特性。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:20:3","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"数据库自增(设置步长) 经过分库分表之后我有十个表，那么我可以让每一个表按照步长来生成自增 ID。比如说第一个表就是生成 1、11、21、31 这种 ID，第二个表就是生成 2、12、22、32 这种 ID。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:21:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"雪花算法 雪花算法采用 64 位来表示一个 ID，其中 1 比特保留，41 比特表示时间戳， 10 比特作为机器 ID，12 比特作为序列号。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:22:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"序列号耗尽 12比特不够用，从时间戳拿比特增加到序列号上 等待下一时刻继续生成(限流) 一般来说可以考虑加长序列号的长度，比如说缩减时间戳，然后挪给序列号 ID。当然也可以更加简单粗暴地将 64 位的 ID 改成 96 位的 ID，那么序列号 ID 就可以有三四十位，即便是国际大厂也不可能用完了。不过，彻底的兜底方 案还是要有的。我们可以考虑引入类似限流的做法，在当前时刻的 ID 已经耗尽 之后，可以让业务方等一下。我们的时间戳一般都是毫秒数，那么业务方最多 就会等一毫秒。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:22:1","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"数据堆积 QA:你设想这么一个场景：你的分库分表是按照 ID 除以 32 的余数来进行的，那么如果你的业务 非常低频，以至于每一个时刻都只生成了尾号为 1 的 ID，那么是不是所有的数据都分到了一 张表里面呢？ 在低频场景下，很容易出现序列号几乎没有增长，从而导致数据在经过分库分 表之后只落到某一张表里面的情况。为了解决这种问题，可以考虑这么做，序 列号部分不再是从 0 开始增长，而是从一个随机数开始增长。还有一个策略就 是序列号从上一时刻的序列号开始增长，但是如果上一时刻序列号已经很大! 了，那么就可以退化为从 0 开始增长。这样的话要比随机数更可控一点，并且 性能也要更好一点。 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:22:2","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"主键内嵌分库分表键 大多数时候，我们会面临一个问题，就是分库分表的键和主键并不是同一个。 比如说在 C 端的订单分库分表，我们可以采用买家 ID 来进行分库分表。但是 一些业务场景，比如说查看订单详情，可能是根据主键又或者是根据订单 SN 来查找的。 那么我们可以考虑借鉴雪花算法的设计，将主键生成策略和分库分表键结合在 一起，也就是说在主键内部嵌入分库分表键。例如，我们可以这样设计订单 ID 的生成策略，在这里我们假设分库分表用的是买家 ID 的后四位。第一段依旧是 采用时间戳，但是第二段我们就换成了这个买家后四位，第三段我们采用随机数。 普遍情况下，我们都是用买家 ID 来查询对应的订单信息。在别的场景下，比如 说我们只有一个订单 ID，这种时候我们可以取出订单 ID 里嵌入进去的买家 ID 后四位，来判断数据存储在哪个库、哪个表。类似的设计还有答题记录按照答 题者 ID 来分库分表，但是答题记录 ID 本身可以嵌入这个答题者 ID 中用于分 库分表的部分。 分库分表分页 ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:23:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["数据库"],"content":"分库分表 三种算法 哈希分库分表：ID 取余 范围分库分表：按照 ID 范围，日期范围 中间表：引入一个中间表来记录映射关系 分布式事务，如何同时保证分库分表、ACID和高性能？ ","date":"2024-09-01","objectID":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/:24:0","tags":null,"title":"数据库_MySQL","uri":"/%E6%95%B0%E6%8D%AE%E5%BA%93_mysql%E9%97%AE%E9%A2%98/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_WaitGroup WaitGroup (协同等待，任务编排利器) ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:0:0","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"方法 func (wg *WaitGroup) Add(delta int) // 用来设置 WaitGroup 的计数值 func (wg *WaitGroup) Done() // 用来将 WaitGroup 的计数值减 1，其实就是调用了 Add(-1) func (wg *WaitGroup) Wait() // 调用这个方法的 goroutine 会一直阻塞，直到 WaitGroup 的计数值变为 0","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:1:0","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"基本使用 type WaitGroup struct { // 避免复制使用的一个技巧，可以告诉vet工具违反了复制使用的规则 noCopy noCopy // 64bit(8bytes)的值分成两段，高32bit是计数值，低32bit是waiter的计数 // 另外32bit是用作信号量的 // 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样，具体处理看下面的方法 // 总之，会找到对齐的那64bit作为state，其余的32bit做信号量 state1 [3]uint32 } // 得到state的地址和信号量的地址 func (wg *WaitGroup) state() (statep *uint64, semap *uint32) { if uintptr(unsafe.Pointer(\u0026wg.state1))%8 == 0 { // 如果地址是64bit对齐的，数组前两个元素做state，后一个元素做信号量 return (*uint64)(unsafe.Pointer(\u0026wg.state1)), \u0026wg.state1[2] } else { // 如果地址是32bit对齐的，数组后两个元素用来做state，它可以用来做64bit的原子操作，第一个元素32bit用来做信号量 return (*uint64)(unsafe.Pointer(\u0026wg.state1[1])), \u0026wg.state1[0] } }64 位环境下：waiter 数 | WaitGroup 的计数值 | 信号量 32 位环境下：信号量 | waiter 数 | WaitGroup 的计数值 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:2:0","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"常见问题 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:3:0","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"1.计数器设置为负值 WaitGroup 的计数器的值必须大于等于 0，否则会 panic。 虽然 Add 可以传入负值，但是还是要用 Done 比较稳妥。 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:3:1","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"2. 调用 Done 方法的次数过多，超过了 WaitGroup 的计数值 设置多少次，调用多少次的 Done。否则会造成死锁(Done 次数调用少于设置值)，或者造成 Panic (Done 次数调用多于设置值)。 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:3:2","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"3. 不期望的 Add 时机 等所有的 Add 方法调用之后再次调用 Wait。 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:3:3","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"4. 前一个 Wait 还没结束就重用 WaitGroup 只要 WaitGroup 的值重归于 0 就可以重新使用，否则会 panic。 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:3:4","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"noCopy: 辅助 vet 检查 它就是指示 vet 工具在做检查的时候，这个数据结构不能做值复制使用。更严谨地说，是不能在第一次使用之后复制使用。 ","date":"2024-08-15","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/:4:0","tags":null,"title":"Go并发_基本并发原语_WaitGroup","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADwaitgroup/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_RWMutex RWMutex 概念：RWMutex 在某一时刻只能由任意数量的 reader 持有，或者是只被单个的 writer 持有。 方法： Lock/Unlock: 如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。 RLock/Unlock：如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。 Rlocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法。 TryRLock/TryLock: 尝试获取，同 Mutex。 其他用法和注意和 Mutex 相似。 ","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:0:0","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"常见问题 Read-preferring：读优先的设计可以提供很高的并发性，但是，在竞争激烈的情况下可能会导致写饥饿。 Write-preferring：避免写饥饿，阻塞的是新来 reader， 让已经在工作的 reader 工作完成。 不指定优先级：平等对待，解决饥饿。 Go 标准库中的 RWMutex 设计是 Write-preferring 方案。一个正在阻塞的 Lock 调用会排除新的 reader 请求到锁。 ","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:1:0","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"基本使用 type RWMutex struct { w Mutex // 互斥锁解决多个writer的竞争 writerSem uint32 // writer信号量 readerSem uint32 // reader信号量 readerCount int32 // reader的数量 记录当前 reader 的数量（以及是否有 writer 竞争锁） readerWait int32 // 记录 writer 请求锁时需要等待 read 完成的 reader 的数量 }","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:2:0","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"RLock/RUnLock func (rw *RWMutex) RLock() { if atomic.AddInt32(\u0026rw.readerCount, 1) \u003c 0 { // rw.readerCount是负值的时候，意味着此时有writer等待请求锁，因为writer优先级高，所以把后来的reader阻塞休眠 runtime_SemacquireMutex(\u0026rw.readerSem, false, 0) } } func (rw *RWMutex) RUnlock() { if r := atomic.AddInt32(\u0026rw.readerCount, -1); r \u003c 0 { rw.rUnlockSlow(r) // 有等待的writer } } func (rw *RWMutex) rUnlockSlow(r int32) { if atomic.AddInt32(\u0026rw.readerWait, -1) == 0 { // 最后一个reader了，writer终于有机会获得锁了 runtime_Semrelease(\u0026rw.writerSem, false, 1) } }","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:2:1","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"Lock 一旦一个 writer 获得了内部的互斥锁，就会反转 readerCount 字段，把它从原来的正整数 readerCount(\u003e=0) 修改为负数（readerCount-rwmutexMaxReaders），让这个字段保持两个含义（既保存了 reader 的数量，又表示当前有 writer）。 func (rw *RWMutex) Lock() { // 首先解决其他writer竞争问题 rw.w.Lock() // 反转readerCount，告诉reader有writer竞争锁 r := atomic.AddInt32(\u0026rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders // 如果当前有reader持有锁，那么需要等待 if r != 0 \u0026\u0026 atomic.AddInt32(\u0026rw.readerWait, r) != 0 { runtime_SemacquireMutex(\u0026rw.writerSem, false, 0) } }","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:2:2","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"Unlock 当一个 writer 释放锁的时候，它会再次反转 readerCount 字段，即加上 rwmutexMaxReaders 这个常数，变成了正数。 func (rw *RWMutex) Unlock() { // 告诉reader没有活跃的writer了 r := atomic.AddInt32(\u0026rw.readerCount, rwmutexMaxReaders) // 唤醒阻塞的reader们 for i := 0; i \u003c int(r); i++ { runtime_Semrelease(\u0026rw.readerSem, false, 0) } // 释放内部的互斥锁 rw.w.Unlock() }","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:2:3","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"常见踩坑点 ","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:3:0","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"1. 不可复制 同 Mutex ","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:3:1","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"2. 重入导致死锁 Mutex 本身重入就有问题，更别说基于它实现的读写锁，writer 重入调用 Lock 的时候，就会出现死锁。 reader 获取锁， writer 会阻塞等待，reader 重入时调用 writer 的写操作，互相依赖形成死锁。 当一个 writer 请求锁的时候，如果已经有一些活跃的 reader，它会等待这些活跃的 reader 完成，如果之后活跃的 reader 再依赖新的 reader 的话，这些新的 reader 就会等待 writer 释放锁之后才能继续执行，这就形成了一个环形依赖： writer 依赖活跃的 reader -\u003e 活跃的 reader 依赖新来的 reader -\u003e 新来的 reader 依赖 writer。 第三种情况举例： package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var mu sync.RWMutex // writer,稍微等待，然后制造一个调用Lock的场景 go func() { time.Sleep(200 * time.Millisecond) mu.Lock() fmt.Println(\"Lock\") time.Sleep(100 * time.Millisecond) mu.Unlock() fmt.Println(\"Unlock\") }() go func() { factorial(\u0026mu, 10) // 计算10的阶乘, 10! }() select {} } // 递归调用计算阶乘 func factorial(m *sync.RWMutex, n int) int { if n \u003c 1 { // 阶乘退出条件 return 0 } fmt.Println(\"RLock\") m.RLock() defer func() { fmt.Println(\"RUnlock\") m.RUnlock() }() time.Sleep(100 * time.Millisecond) return factorial(m, n-1) * n // 递归调用 }","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:3:2","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"3.释放未加锁的 RWMutex 必须要成对出现 Lock/UnLock，RLock/RUnLock。 ","date":"2024-08-14","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/:3:3","tags":null,"title":"Go并发_基本并发原语_RWMutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADrwmutex/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_Pool Pool sync.Pool 用与缓存临时使用的对象，避免反复创建带来的性能损耗。所以如果没有别的对象引用，会被垃圾回收掉。 ","date":"2024-08-13","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/:0:0","tags":null,"title":"Go并发_基本并发原语_Pool","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/"},{"categories":["Golang"],"content":"特性 sync.Pool 本身就是线程安全的，多个 goroutine 可以并发地调用它的方法存取对象 sync.Pool 不可在使用之后再复制使用。 ","date":"2024-08-13","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/:1:0","tags":null,"title":"Go并发_基本并发原语_Pool","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/"},{"categories":["Golang"],"content":"方法 New、Get 和 Put。 New Pool struct 包含一个 New 字段，这个字段的类型是函数 func() interface{}。当调用 Pool 的 Get 方法从池中获取元素，没有更多的空闲元素可返回时，就会调用这个 New 方法来创建新的元素。如果你没有设置 New 字段，没有更多的空闲元素可返回时，Get 方法将返回 nil，表明当前没有可用的元素。 Get 从 Pool 取走一个元素，从 Pool 移除并返回。可能为 nil（Pool.New 字段没有设置，又没有空闲元素可以返回）。 Put 将一个元素提交个 Pool， 提交一个 nil 值，直接忽略。 ","date":"2024-08-13","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/:2:0","tags":null,"title":"Go并发_基本并发原语_Pool","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/"},{"categories":["Golang"],"content":"原理 type Pool struct { noCopy noCopy local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array New func() any }在 STW 时，victim 被清空，local 赋值给 victim，local 置为 nil，Get 取值的时候是从 victim 中获取。 ","date":"2024-08-13","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/:3:0","tags":null,"title":"Go并发_基本并发原语_Pool","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/"},{"categories":["Golang"],"content":"local 字段 local 字段包含一个 poolLocalInternal 字段，并提供 CPU 缓存对齐，从而避免 false sharing。 poolLocalInternal 也包含两个字段：private 和 shared。 private，代表一个缓存的元素，而且只能由相应的一个 P 存取。因为一个 P 同时只能执行一个 goroutine，所以不会有并发的问题。 shared，可以由任意的 P 访问，但是只有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相当于只有一个本地的 P 作为生产者（Producer），多个 P 作为消费者（Consumer），它是使用一个 local-free 的 queue 列表实现的。 ","date":"2024-08-13","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/:3:1","tags":null,"title":"Go并发_基本并发原语_Pool","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADpool/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_Once Once Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。 ","date":"2024-08-12","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/:0:0","tags":null,"title":"Go并发_基本并发原语_Once","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/"},{"categories":["Golang"],"content":"方法 func (o *Once) Do(f func())可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。 ","date":"2024-08-12","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/:1:0","tags":null,"title":"Go并发_基本并发原语_Once","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/"},{"categories":["Golang"],"content":"常见错误 （罕见） ","date":"2024-08-12","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/:2:0","tags":null,"title":"Go并发_基本并发原语_Once","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/"},{"categories":["Golang"],"content":"1. 死锁 Do 方法会执行一次 f，但是如果 f 中再次调用这个 Once 的 Do 方法的话，就会导致死锁的情况出现。 func main() { var once sync.Once once.Do(func() { once.Do(func() { fmt.Println(\"初始化\") }) }) }","date":"2024-08-12","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/:2:1","tags":null,"title":"Go并发_基本并发原语_Once","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/"},{"categories":["Golang"],"content":"2.未初始化 如果执行 f 的时候 panic，未初始化成功，但是 Once 依旧认为执行成功，不会再次执行 f。 优化 Once 的并发原语，增加了 f 的 error 返回和 Once 的 error 返回，通过判断是否为 nil 来看是否将 done 设为 1。 // 一个功能更加强大的Once type Once struct { m sync.Mutex done uint32 } // 传入的函数f有返回值error，如果初始化失败，需要返回失败的error // Do方法会把这个error返回给调用者 func (o *Once) Do(f func() error) error { if atomic.LoadUint32(\u0026o.done) == 1 { //fast path return nil } return o.slowDo(f) } // 如果还没有初始化 func (o *Once) slowDo(f func() error) error { o.m.Lock() defer o.m.Unlock() var err error if o.done == 0 { // 双检查，还没有初始化 err = f() if err == nil { // 初始化成功才将标记置为已初始化 atomic.StoreUint32(\u0026o.done, 1) } } return err }","date":"2024-08-12","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/:2:2","tags":null,"title":"Go并发_基本并发原语_Once","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADonce/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_Mutex Mutex (互斥锁/排他锁) 临界区 ： 在并发编程中，如果程序中的一部分会被并发访问或修改，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做临界区。 适用场景 ： 共享资源 任务编排 消息传递 检测工具：Go race detector (在运行时，触发才可以检测) $ go test -race mypkg // test the package $ go run -race mysrc.go // compile and run the program $ go build -race mycmd // build the command $ go install -race mypkg // install the package","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:0:0","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Mutex 的基本使用 type Mutex struct { state int32 sema uint32 } // state 字段被分为 4 部分 const ( mutexLocked = 1 \u003c\u003c iota // 持有锁的标记 mutexWoken // 唤醒标记 mutexStarving // 饥饿标记 mutexWaiterShift = iota // 阻塞等待的 waiter 数量,其最大为 2^(32-3)-1 )方法： func(m *Mutex)Lock() // 获得锁 func(m *Mutex)Unlock() // 释放锁当一个 goroutine 通过调用 Lock 方法获得了这个锁的拥有权后， 其它请求锁的 goroutine 就会阻塞在 Lock 方法的调用上，直到锁被释放并且自己获取到了这个锁的拥有权。 var mu sync.Mutex // Mutex 的零值是还没有 goroutine 等待的未加锁的状态，所以你不需要额外的初始化，直接声明变量（如 var mu sync.Mutex）即可","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:1:0","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"注意 初始化 strcut，不必初始化 Mutex 字段 匿名嵌入 Mutex，可以直接调用其方法 多个字段，把 Mutex 放在要控制的字段上面，便于维护。 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:1:1","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"锁获取机制 等待的 goroutine 们是以 FIFO 排队的 当 Mutex 处于正常模式时，若此时没有新 goroutine 与队头 goroutine 竞争，则队头 goroutine 获得。若有新 goroutine 竞争大概率新 goroutine 获得。 当队头 goroutine 竞争锁失败 1ms 后，它会将 Mutex 调整为饥饿模式。进入饥饿模式后，锁的所有权会直接从解锁 goroutine 移交给队头 goroutine ，此时新来的 goroutine 直接放入队尾。 当一个 goroutine 获取锁后，如果发现自己满足下列条件中的任何一个： 它是队列中最后一个。 它等待锁的时间少于 1ms ，则将锁切换回正常模式。 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:1:2","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Mutex 错误场景 Lock/Unlock 不是成对出现 Copy 已使用的 Mutex 重入 死锁 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:2:0","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Lock/Unlock 不是成对出现 策略：善用 defer 或者用完就关 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:2:1","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Copy 已使用的 Mutex 场景：如果你要复制一个已经加锁的 Mutex 给一个新的变量，那么新的刚初始化的变量居然被加锁了 原理：mutex 的 state 是公共的，如果复制这个对象之前已经是加锁状态，那么赋值之后就已经有锁了。 type Counter struct { sync.Mutex Count int } func main() { var c Counter c.Lock() defer c.Unlock() c.Count++ foo(c) // 复制锁 } // 这里Counter的参数是通过复制的方式传入的 func foo(c Counter) { c.Lock() defer c.Unlock() fmt.Println(\"in foo\") }策略：使用 go vet 检查，go vet xxx.go 及时发现问题。使用了 Locker 接口的就会被分析到。 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:2:2","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"重入 概念：一个函数拥有某个锁后，还可以不断调用锁，叫可重入锁(递归锁)。 注意： Mutex 不是可重入的锁。 实现可重入锁 通过 hacker 的方式获取到 goroutine id，记录下获取锁的 goroutine id，它可以实现 Locker 接口。 调用 Lock/Unlock 方法时，由 goroutine 提供一个 token，用来标识它自己。 1.goroutine id package RecursiveMutex import ( \"fmt\" \"github.com/petermattis/goid\" \"sync\" \"sync/atomic\" ) // RecursiveMutex 包装一个Mutex,实现可重入 type RecursiveMutex struct { sync.Mutex owner int64 // 当前持有锁的goroutine id recursion int32 // 这个goroutine 重入的次数 } func (m *RecursiveMutex) Lock() { gid := goid.Get() // 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入 if atomic.LoadInt64(\u0026m.owner) == gid { m.recursion++ return } m.Mutex.Lock() // 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1 atomic.StoreInt64(\u0026m.owner, gid) m.recursion = 1 } func (m *RecursiveMutex) Unlock() { gid := goid.Get() // 非持有锁的goroutine尝试释放锁，错误的使用 if atomic.LoadInt64(\u0026m.owner) != gid { panic(fmt.Sprintf(\"wrong the owner(%d): %d!\", m.owner, gid)) } // 调用次数减1 m.recursion-- if m.recursion != 0 { // 如果这个goroutine还没有完全释放，则直接返回 return } // 此goroutine最后一次调用，需要释放锁 atomic.StoreInt64(\u0026m.owner, -1) m.Mutex.Unlock() }2.token package RecursiveMutex import ( \"fmt\" \"sync\" \"sync/atomic\" ) // Token方式的递归锁 type TokenRecursiveMutex struct { sync.Mutex token int64 recursion int32 } // 请求锁，需要传入token func (m *TokenRecursiveMutex) Lock(token int64) { if atomic.LoadInt64(\u0026m.token) == token { //如果传入的token和持有锁的token一致，说明是递归调用 m.recursion++ return } m.Mutex.Lock() // 传入的token不一致，说明不是递归调用 // 抢到锁之后记录这个token atomic.StoreInt64(\u0026m.token, token) m.recursion = 1 } // 释放锁 func (m *TokenRecursiveMutex) Unlock(token int64) { if atomic.LoadInt64(\u0026m.token) != token { // 释放其它token持有的锁 panic(fmt.Sprintf(\"wrong the owner(%d): %d!\", m.token, token)) } m.recursion-- // 当前持有这个锁的token释放锁 if m.recursion != 0 { // 还没有回退到最初的递归调用 return } atomic.StoreInt64(\u0026m.token, 0) // 没有递归调用了，释放锁 m.Mutex.Unlock() }","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:2:3","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"死锁 概念：两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。 必要条件 互斥 持有和等待 不可剥夺 环路等待 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:2:4","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Mutex 扩展 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:3:0","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"TryLock 概念： 一个 goroutine 调用 TryLock， 能拿到就拿，拿不到直接返回 false 并不会阻塞。 ","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:3:1","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"获取等待者数量等指标 package main import ( \"fmt\" \"sync\" \"sync/atomic\" \"time\" \"unsafe\" ) const ( mutexLocked = 1 \u003c\u003c iota // mutex is locked mutexWoken mutexStarving mutexWaiterShift = iota ) type Mutex struct { sync.Mutex } func (m *Mutex) Count() int { // 获取state字段的值 v := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026m.Mutex))) v = v\u003e\u003emutexWaiterShift + (v \u0026 mutexLocked) return int(v) } // 锁是否被持有 func (m *Mutex) IsLocked() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026m.Mutex))) return state\u0026mutexLocked == mutexLocked } // 是否有等待者被唤醒 func (m *Mutex) IsWoken() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026m.Mutex))) return state\u0026mutexWoken == mutexWoken } // 锁是否处于饥饿状态 func (m *Mutex) IsStarving() bool { state := atomic.LoadInt32((*int32)(unsafe.Pointer(\u0026m.Mutex))) return state\u0026mutexStarving == mutexStarving } func count() { var mu Mutex for i := 0; i \u003c 1000; i++ { // 启动1000个goroutine go func() { mu.Lock() time.Sleep(time.Second) mu.Unlock() }() } time.Sleep(time.Second) // 输出锁的信息 fmt.Printf(\"waitings: %d, isLocked: %t, woken: %t, starving: %t\\n\", mu.Count(), mu.IsLocked(), mu.IsWoken(), mu.IsStarving()) } func main() { count() }","date":"2024-08-11","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/:3:2","tags":null,"title":"Go并发_基本并发原语_Mutex","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADmutex/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_Context Context 上下文联系。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:0:0","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"使用场景 上下文信息传递 （request-scoped），比如处理 http 请求、在请求处理链路上传递信息 控制子 goroutine 的运行 超时控制调用 取消的方法调用 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:1:0","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"基本使用 type Context interface { Deadline() (deadline time.Time, ok bool) // 方法会返回这个 Context 被取消的截止日期。如果没有设置截止日期，ok 的值是 false。 Done() \u003c-chan struct{} // 方法返回一个 Channel 对象。在 Context 被取消时，此 Channel 会被 close，如果没被取消，可能会返回 nil。 Err() error // Value(key interface{}) interface{} // 返回此 ctx 中和指定的 key 相关联的 value。 }","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:0","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"生成顶层 Context 的方法、 context.Background()：返回一个非 nil 的、空的 Context，没有任何值，不会被 cancel，不会超时，没有截止日期。一般用在主函数、初始化、测试以及创建根 Context 的时候。 context.TODO()：Background() 的别名，不知道用啥或者不知道什么上下文用这个。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:1","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"默认原则 一般函数使用 Context 的时候，会把这个参数放在第一个参数的位置。 从来不把 nil 当做 Context 类型的参数值，可以用 context.TODO()。 Context 只用来临时做函数之间的上下文透传，不能持久化 Context 或者把 Context 长久保存。 key 的类型不应该是字符串类型或者其它内建类型，否则容易在包之间使用 Context 时候产生冲突。使用 WithValue 时，key 的类型应该是自己定义的类型。 常常使用 struct{}作为底层类型定义 key 的类型。对于 exported key 的静态类型，常常是接口或者指针。这样可以尽量减少内存分配。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:2","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"WithValue 它持有一个 key-value 键值对，还持有 parent 的 Context。它覆盖了 Value 方法，优先从自己的存储中检查这个 key，不存在的话会从 parent 中继续检查，链式查找。 ctx = context.TODO() ctx = context.WithValue(ctx, \"key1\", \"0001\") ctx = context.WithValue(ctx, \"key2\", \"0001\") ctx = context.WithValue(ctx, \"key3\", \"0001\") ctx = context.WithValue(ctx, \"key4\", \"0004\") fmt.Println(ctx.Value(\"key1\"))查找key -\u003e key4 -\u003e key3 -\u003e key2 -\u003e key1 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:3","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"WithCancel ctx, cancelFunc := context.WithCancel() defer cancelFunc()任务完成和中途放弃都需要调用 cancelFunc(), context 才会释放资源。 cancel 是向下传递，其依赖的子孙都会被 cancel，但是不会向上传递。 被取消时，err 字段为 var Canceled = errors.New(\"context canceled\") 错误。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:4","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"WithDeadline WithDeadline 会返回一个 parent 的副本，并且设置了一个不晚于参数 d 的截止时间。 timerCtx 的 Done 被 Close 掉的原因。 截止时间到了 cancel 函数被调用 parent 的 Done 被 close 同 cancelCtx 一样，cancelFunc() 一定要调用。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:5","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"WithTimeout 同 WithDeadline ，一个是截至时间，一个是超时时间。 ","date":"2024-08-10","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/:2:6","tags":null,"title":"Go并发_基本并发原语_Context","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcontext/"},{"categories":["Golang"],"content":"Go并发_基本并发原语_Cond Cond 目的：为等待 / 通知场景下的并发问题提供支持。 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:0:0","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"基本用法 Cond 并发原语初始化的时候，需要关联一个 Locker 接口的实例，一般我们使用 Mutex 或者 RWMutex。 type Cond func NeWCond(l Locker) *Cond func (c *Cond) Broadcast() func (c *Cond) Signal() func (c *Cond) Wait()Signal 方法：允许调用者 Caller 唤醒一个等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则需要从等待队列中移除第一个 goroutine 并把它唤醒。 Broadcast 方法：允许调用者 Caller 唤醒所有等待此 Cond 的 goroutine。如果此时没有等待的 goroutine，显然无需通知 waiter；如果 Cond 等待队列中有一个或者多个等待的 goroutine，则清空所有等待的 goroutine，并全部唤醒。在其他编程语言中，比如 Java 语言中，Broadcast 方法也被叫做 notifyAll 方法。 Wait 方法：会把调用者 Caller 放入 Cond 的等待队列中并阻塞，直到被 Signal 或者 Broadcast 的方法从等待队列中移除并唤醒。 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:1:0","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"实现原理 type Cond struct { noCopy noCopy L Locker // 当观察或者修改等待条件的时候需要加锁 notify notifyList // 等待队列 checker copyChecker // 是一个辅助结构，可以在运行时检查 Cond 是否被复制使用。 } func NewCond(l Locker) *Cond { return \u0026Cond{L: l} } func (c *Cond) Wait() { c.checker.check() // 增加到等待队列中 t := runtime_notifyListAdd(\u0026c.notify) c.L.Unlock() // 阻塞休眠直到被唤醒 runtime_notifyListWait(\u0026c.notify, t) c.L.Lock() } func (c *Cond) Signal() { c.checker.check() runtime_notifyListNotifyOne(\u0026c.notify) } func (c *Cond) Broadcast() { c.checker.check() runtime_notifyListNotifyAll(\u0026c.notify) }Wait 把调用者加入到等待队列时会释放锁，在被唤醒之后还会请求锁。在阻塞休眠期间，调用者是不持有锁的，这样能让其他 goroutine 有机会检查或者更新等待变量。 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:2:0","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"常见错误 package main import ( \"log\" \"math/rand\" \"sync\" \"time\" ) func main() { cond := sync.NewCond(\u0026sync.Mutex{}) var ready int for i := 0; i \u003c 10; i++ { go func(i int) { time.Sleep(time.Duration(rand.Int63n(10)) * time.Second) cond.L.Lock() ready++ cond.L.Unlock() log.Printf(\"#%d\", i) cond.Broadcast() }(i) } go func() { cond.L.Lock() for ready != 10 { cond.Wait() log.Println(\"裁判员被唤醒一次\") } cond.L.Unlock() }() time.Sleep(time.Second * 10) log.Println(\"所有运动员都准备就绪。比赛开始，3，2，1, ......\") }","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:3:0","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"1.调用 Wait 的时候没有加锁 上述黑字部分即为原因，加入队列后会释放锁，所以要先获取锁。 注释代码 26 即可出现错误。 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:3:1","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"2.只调用了一次 Wait，没有检查等待条件是否满足，结果条件没满足，程序就继续执行了。 注释代码 27 和 30 即可出现错误。 waiter goroutine 被唤醒不等于等待条件被满足，只是多了一次检查的机会 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:3:2","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"和 Channel 对比 很多情况下，项目中更适用于 Channel，但是 Cond 也有属于自己的优势。 Cond 和一个 Locker 关联，可以利用这个 Locker 对相关的依赖条件更改提供保护。 Cond 可以同时支持 Signal 和 Broadcast 方法，而 Channel 只能同时支持其中一种。 Cond 的 Broadcast 方法可以被重复调用。等待条件再次变成不满足的状态后，我们又可以调用 Broadcast 再次唤醒等待的 goroutine。这也是 Channel 不能支持的，Channel 被 close 掉了之后不支持再 open。 ","date":"2024-08-09","objectID":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/:4:0","tags":null,"title":"Go并发_基本并发原语_Cond","uri":"/go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%ADcond/"},{"categories":["Golang"],"content":"Go并发_原子操作_atomic 原子操作 原子操作是指在并发编程中，某个操作要么完全执行，要么完全不执行，不会被其他线程或任务打断。这种特性确保了在多线程环境下的操作的完整性和一致性。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:0:0","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"方法 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:0","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Add func AddInt32(addr *int32, delta int32) (new int32) 可以加一个负数， 对于无符号的整数来说，可以利用补码规则，由减法变加法。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:1","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"CAS（CompareAndSwap） func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 比较当前 addr 地址里的值是不是 old，如果不等于 old，就返回 false；如果等于 old，就把此地址的值替换成 new 值，返回 true。这就相当于“判断相等才替换”。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:2","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Swap func SwapInt32(addr *int32, new int32) (old int32) 不需要比较相等，直接替换。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:3","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Load Load 方法会取出 addr 地址中的值，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Load 是一个原子操作。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:4","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Store Store 方法会把一个值存入到指定的 addr 地址中，即使在多处理器、多核、有 CPU cache 的情况下，这个操作也能保证 Store 是一个原子操作。别的 goroutine 通过 Load 读取出来，不会看到存取了一半的值。 ","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:5","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Value stomic 的特殊类型，Value。它可以CAS/Swap/Load/Store。 测试用法： package main import ( \"log\" \"math/rand\" \"sync\" \"sync/atomic\" \"time\" ) type Config struct { NodeName string Addr string Count int32 } func loadNewConfig() Config { return Config{ NodeName: \"1\", Addr: \"2\", Count: rand.Int31(), } } func main() { var config atomic.Value config.Store(loadNewConfig()) cond := sync.NewCond(\u0026sync.Mutex{}) go func() { for { time.Sleep(time.Second * 3) config.Store(loadNewConfig()) cond.Broadcast() } }() go func() { for { cond.L.Lock() cond.Wait() c := config.Load().(Config) log.Printf(\"%+v\", c) cond.L.Unlock() } }() select {} }","date":"2024-08-08","objectID":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/:1:6","tags":null,"title":"Go并发_原子操作_atomic","uri":"/go%E5%B9%B6%E5%8F%91%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9Catomic/"},{"categories":["Golang"],"content":"Go并发_扩展 SingleFlight 多个 Goroutine 同时调用一个函数，只会让一个调用，并把结果返回给所有的调用者。 **使用互斥锁和 Map 来实现的。 ","date":"2024-08-07","objectID":"/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/:0:0","tags":null,"title":"Go并发_扩展","uri":"/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/"},{"categories":["Golang"],"content":"和 sync.Once 的区别 sync.Once 主要用于单次的初始化，而 SingleFlight 主要用在合并并发请求的场景中。 CyclicBarrier func New(parties int) CyclicBarrier // 它只需要一个参数，来指定循环栅栏参与者的数量； func NewWithAction(parties int, barrierAction func() error) CyclicBarrier // 它额外提供一个函数，可以在每一次到达执行点的时候执行一次。具体的时间点是在最后一个参与者到达之后，但是其它的参与者还未被放行之前。我们可以利用它，做放行之前的一些共享状态的更新等操作。举例成产 H2O package water import ( \"context\" \"github.com/marusama/cyclicbarrier\" \"golang.org/x/sync/semaphore\" \"math/rand\" \"sort\" \"sync\" \"testing\" \"time\" ) // 定义水分子合成的辅助数据结构 type H2O struct { semaH *semaphore.Weighted // 氢原子的信号量 semaO *semaphore.Weighted // 氧原子的信号量 b cyclicbarrier.CyclicBarrier // 循环栅栏，用来控制合成 } func New() *H2O { return \u0026H2O{ semaH: semaphore.NewWeighted(2), //氢原子需要两个 semaO: semaphore.NewWeighted(1), // 氧原子需要一个 b: cyclicbarrier.New(3), // 需要三个原子才能合成 } } func (h2o *H2O) hydrogen(releaseHydrogen func()) { h2o.semaH.Acquire(context.Background(), 1) releaseHydrogen() // 输出H h2o.b.Await(context.Background()) //等待栅栏放行 h2o.semaH.Release(1) // 释放氢原子空槽 } func (h2o *H2O) oxygen(releaseOxygen func()) { h2o.semaO.Acquire(context.Background(), 1) releaseOxygen() // 输出O h2o.b.Await(context.Background()) //等待栅栏放行 h2o.semaO.Release(1) // 释放氢原子空槽 } // 单元测试 func TestWaterFactory(t *testing.T) { //用来存放水分子结果的channel var ch chan string releaseHydrogen := func() { ch \u003c- \"H\" } releaseOxygen := func() { ch \u003c- \"O\" } // 300个原子，300个goroutine,每个goroutine并发的产生一个原子 var N = 100 ch = make(chan string, N*3) h2o := New() // 用来等待所有的goroutine完成 var wg sync.WaitGroup wg.Add(N * 3) // 200个氢原子goroutine for i := 0; i \u003c 2*N; i++ { go func() { time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond) h2o.hydrogen(releaseHydrogen) wg.Done() }() } // 100个氧原子goroutine for i := 0; i \u003c N; i++ { go func() { time.Sleep(time.Duration(rand.Intn(100)) * time.Millisecond) h2o.oxygen(releaseOxygen) wg.Done() }() } //等待所有的goroutine执行完 wg.Wait() // 结果中肯定是300个原子 if len(ch) != N*3 { t.Fatalf(\"expect %d atom but got %d\", N*3, len(ch)) } // 每三个原子一组，分别进行检查。要求这一组原子中必须包含两个氢原子和一个氧原子，这样才能正确组成一个水分子。 var s = make([]string, 3) for i := 0; i \u003c N; i++ { s[0] = \u003c-ch s[1] = \u003c-ch s[2] = \u003c-ch sort.Strings(s) water := s[0] + s[1] + s[2] if water != \"HHO\" { t.Fatalf(\"expect a water molecule but got %s\", water) } } }","date":"2024-08-07","objectID":"/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/:1:0","tags":null,"title":"Go并发_扩展","uri":"/go%E5%B9%B6%E5%8F%91_%E6%89%A9%E5%B1%95/"},{"categories":["Golang"],"content":"Go并发_分组操作 分组操作 分组执行一批相同或类似的任务。 ErrGroup 大任务拆成几个小任务并发执行 ","date":"2024-08-06","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/:0:0","tags":null,"title":"Go并发_分组操作","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["Golang"],"content":"WithContext func WithContext(ctx context.Context) (*Group, context.Context)这个方法返回一个 Group 实例，同时还会返回一个使用 context.WithCancel(ctx) 生成的新 Context。一旦有一个子任务返回错误，或者是 Wait 调用返回，这个新 Context 就会被 cancel。 如果传递给 WithContext 的 ctx 参数，是一个可以 cancel 的 Context 的话，那么，它被 cancel 的时候，并不会终止正在执行的子任务。(可以由子任务终止，向上传递) ","date":"2024-08-06","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/:1:0","tags":null,"title":"Go并发_分组操作","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["Golang"],"content":"Go func (g *Group) Go(f func() error)任务成功返回 nil，否则返回 error，并且会 cancel 那个新的 Context。 ","date":"2024-08-06","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/:2:0","tags":null,"title":"Go并发_分组操作","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["Golang"],"content":"Wait func (g *Group) Wait() error类似于 WaitGroup，等所有的子任务完成后，就会返回，否则阻塞等待。如果有多个子任务返回错误，它只会返回第一个出现的错误。 ","date":"2024-08-06","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/:3:0","tags":null,"title":"Go并发_分组操作","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["Golang"],"content":"Pipeline 任务流水线 package main import ( ...... \"golang.org/x/sync/errgroup\" ) // 一个多阶段的pipeline.使用有限的goroutine计算每个文件的md5值. func main() { m, err := MD5All(context.Background(), \".\") if err != nil { log.Fatal(err) } for k, sum := range m { fmt.Printf(\"%s:\\t%x\\n\", k, sum) } } type result struct { path string sum [md5.Size]byte } // 遍历根目录下所有的文件和子文件夹,计算它们的md5的值. func MD5All(ctx context.Context, root string) (map[string][md5.Size]byte, error) { g, ctx := errgroup.WithContext(ctx) paths := make(chan string) // 文件路径channel g.Go(func() error { defer close(paths) // 遍历完关闭paths chan return filepath.Walk(root, func(path string, info os.FileInfo, err error) error { ...... //将文件路径放入到paths return nil }) }) // 启动20个goroutine执行计算md5的任务，计算的文件由上一阶段的文件遍历子任务生成. c := make(chan result) const numDigesters = 20 for i := 0; i \u003c numDigesters; i++ { g.Go(func() error { for path := range paths { // 遍历直到paths chan被关闭 ...... // 计算path的md5值，放入到c中 } return nil }) } go func() { g.Wait() // 20个goroutine以及遍历文件的goroutine都执行完 close(c) // 关闭收集结果的chan }() m := make(map[string][md5.Size]byte) for r := range c { // 将md5结果从chan中读取到map中,直到c被关闭才退出 m[r.path] = r.sum } // 再次调用Wait，依然可以得到group的error信息 if err := g.Wait(); err != nil { return nil, err } return m, nil }","date":"2024-08-06","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/:4:0","tags":null,"title":"Go并发_分组操作","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E7%BB%84%E6%93%8D%E4%BD%9C/"},{"categories":["Golang"],"content":"Go并发_分布式(etcd) 分布式 分布式（Distributed）是指将系统的组件或服务分散在多个物理或虚拟位置上，以便于处理、存储和管理数据。分布式系统通常由多个计算节点组成，这些节点通过网络进行通信和协作。 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:0:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"选举 func (e *Election) Campaign(ctx context.Context, val string) error把一个节点选举为主节点，并且会设置一个值。这是一个阻塞方法，在调用它的时候会被阻塞，直到满足下面的三个条件之一，才会取消阻塞。 成功当选为主 此方法返回错误 ctx 被取消 func (e *Election) Resign(ctx context.Context) (err error)它的作用是，重新设置 Leader 的值，但是不会重新选主，这个方法会返回新值设置成功或者失败的信息。 func (e *Election) Resign(ctx context.Context) (err error)开始新一次选举。这个方法会返回新的选举成功或者失败的信息。 func (e *Election) Leader(ctx context.Context) (*v3.GetResponse, error)如果当前还没有 Leader，就返回一个错误，可以使用这个方法来查询主节点信息。 func (e *Election) Rev() int64每次主节点的变动都会生成一个新的版本号，可以查询版本号信息。 func (e *Election) Observe(ctx context.Context) \u003c-chan v3.GetResponse返回主节点最近一次变动的信息。 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:1:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"互斥锁 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:2:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"Locker ETCD 提供了简单的 Locker，提供了 Lock/UnLock func NewLocker(s *Session, pfx string) sync.Locker使用demo package main import ( \"flag\" \"log\" \"math/rand\" \"strings\" \"time\" \"github.com/coreos/etcd/clientv3\" \"github.com/coreos/etcd/clientv3/concurrency\" ) var ( addr = flag.String(\"addr\", \"http://127.0.0.1:2379\", \"etcd addresses\") lockName = flag.String(\"name\", \"my-test-lock\", \"lock name\") ) func main() { flag.Parse() rand.Seed(time.Now().UnixNano()) // etcd地址 endpoints := strings.Split(*addr, \",\") // 生成一个etcd client cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() useLock(cli) // 测试锁 } func useLock(cli *clientv3.Client) { // 为锁生成session s1, err := concurrency.NewSession(cli) if err != nil { log.Fatal(err) } defer s1.Close() //得到一个分布式锁 locker := concurrency.NewLocker(s1, *lockName) // 请求锁 log.Println(\"acquiring lock\") locker.Lock() log.Println(\"acquired lock\") // 等待一段时间 time.Sleep(time.Duration(rand.Intn(30)) * time.Second) locker.Unlock() // 释放锁 log.Println(\"released lock\") }","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:2:1","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"Mutex func useMutex(cli *clientv3.Client) { // 为锁生成session s1, err := concurrency.NewSession(cli) if err != nil { log.Fatal(err) } defer s1.Close() m1 := concurrency.NewMutex(s1, *lockName) //在请求锁之前查询key log.Printf(\"before acquiring. key: %s\", m1.Key()) // 请求锁 log.Println(\"acquiring lock\") if err := m1.Lock(context.TODO()); err != nil { log.Fatal(err) } log.Printf(\"acquired lock. key: %s\", m1.Key()) //等待一段时间 time.Sleep(time.Duration(rand.Intn(30)) * time.Second) // 释放锁 if err := m1.Unlock(context.TODO()); err != nil { log.Fatal(err) } log.Println(\"released lock\") }","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:2:2","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"读写锁 package main import ( \"bufio\" \"flag\" \"fmt\" \"log\" \"math/rand\" \"os\" \"strings\" \"time\" \"github.com/coreos/etcd/clientv3\" \"github.com/coreos/etcd/clientv3/concurrency\" recipe \"github.com/coreos/etcd/contrib/recipes\" ) var ( addr = flag.String(\"addr\", \"http://127.0.0.1:2379\", \"etcd addresses\") lockName = flag.String(\"name\", \"my-test-lock\", \"lock name\") action = flag.String(\"rw\", \"w\", \"r means acquiring read lock, w means acquiring write lock\") ) func main() { flag.Parse() rand.Seed(time.Now().UnixNano()) // 解析etcd地址 endpoints := strings.Split(*addr, \",\") // 创建etcd的client cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() // 创建session s1, err := concurrency.NewSession(cli) if err != nil { log.Fatal(err) } defer s1.Close() m1 := recipe.NewRWMutex(s1, *lockName) // 从命令行读取命令 consolescanner := bufio.NewScanner(os.Stdin) for consolescanner.Scan() { action := consolescanner.Text() switch action { case \"w\": // 请求写锁 testWriteLocker(m1) case \"r\": // 请求读锁 testReadLocker(m1) default: fmt.Println(\"unknown action\") } } } func testWriteLocker(m1 *recipe.RWMutex) { // 请求写锁 log.Println(\"acquiring write lock\") if err := m1.Lock(); err != nil { log.Fatal(err) } log.Println(\"acquired write lock\") // 等待一段时间 time.Sleep(time.Duration(rand.Intn(10)) * time.Second) // 释放写锁 if err := m1.Unlock(); err != nil { log.Fatal(err) } log.Println(\"released write lock\") } func testReadLocker(m1 *recipe.RWMutex) { // 请求读锁 log.Println(\"acquiring read lock\") if err := m1.RLock(); err != nil { log.Fatal(err) } log.Println(\"acquired read lock\") // 等待一段时间 time.Sleep(time.Duration(rand.Intn(10)) * time.Second) // 释放写锁 if err := m1.RUnlock(); err != nil { log.Fatal(err) } log.Println(\"released read lock\") }","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:2:3","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"etcd 队列 分布式队列 优先级队列 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:3:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"分布式队列 func NewQueue(client *v3.Client, keyPrefix string) *Queue // 入队 func (q *Queue) Enqueue(val string) error //出队 func (q *Queue) Dequeue() (string, error)分布式队列当前为空，调用 Dequeue 方法的话，会被阻塞，直到有元素可以出队才返回。 demo: package main import ( \"bufio\" \"flag\" \"fmt\" \"log\" \"os\" \"strings\" \"github.com/coreos/etcd/clientv3\" recipe \"github.com/coreos/etcd/contrib/recipes\" ) var ( addr = flag.String(\"addr\", \"http://127.0.0.1:2379\", \"etcd addresses\") queueName = flag.String(\"name\", \"my-test-queue\", \"queue name\") ) func main() { flag.Parse() // 解析etcd地址 endpoints := strings.Split(*addr, \",\") // 创建etcd的client cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() // 创建/获取队列 q := recipe.NewQueue(cli, *queueName) // 从命令行读取命令 consolescanner := bufio.NewScanner(os.Stdin) for consolescanner.Scan() { action := consolescanner.Text() items := strings.Split(action, \" \") switch items[0] { case \"push\": // 加入队列 if len(items) != 2 { fmt.Println(\"must set value to push\") continue } q.Enqueue(items[1]) // 入队 case \"pop\": // 从队列弹出 v, err := q.Dequeue() // 出队 if err != nil { log.Fatal(err) } fmt.Println(v) // 输出出队的元素 case \"quit\", \"exit\": //退出 return default: fmt.Println(\"unknown action\") } } }","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:3:1","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"优先级队列 多提供一个 uint16 的整数，作为优先级。 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:3:2","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"分布式栅栏 Barrier：分布式栅栏。如果持有 Barrier 的节点释放了它，所有等待这个 Barrier 的节点就不会被阻塞，而是会继续执行。 DoubleBarrier：计数型栅栏。在初始化计数型栅栏的时候，我们就必须提供参与节点的数量，当这些数量的节点都 Enter 或者 Leave 的时候，这个栅栏就会放开。所以，我们把它称为计数型栅栏。 ","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:4:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"分布式栅栏 func NewBarrier(client *v3.Client, key string) *Barrier func (b *Barrier) Hold() error // 创建一个 Barrier, 如果已经创建好，有节点调用它的 Wait 就会被阻塞。 func (b *Barrier) Release() error // 释放 Barrier，所有阻塞的节点都被放行。 func (b *Barrier) Wait() error // 阻塞当前调用者，直到 Barrier 被释放。如果栅栏不存在，则不会阻塞。","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:4:1","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"计数型栅栏 func NewDoubleBarrier(s *concurrency.Session, key string, count int) *DoubleBarrier func (b *DoubleBarrier) Enter() error // 当调用者 Enter 则被阻塞。直到一共 count 个节点调用了 Enter，这个 count 个被阻塞的节点才会继续执行。 func (b *DoubleBarrier) Leave() error // 节点调用 Leave 方法的时候，会被阻塞，直到有 count 个节点，都调用了 Leave 方法，这些节点才能继续执行。","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:4:2","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"STM 事务：要么全部成功，要么全失败。 etcd 的事务实现方式是基于 CAS 方式实现的，融合了 Get、Put 和 Delete 操作。 etcd 的事务操作如下，分为条件块、成功块和失败块，条件块用来检测事务是否成功，如果成功，就执行 Then(…)，如果失败，就执行 Else(…)： Txn().If(cond1, cond2, ...).Then(op1, op2, ...,).Else(op1’, op2’, …)转账例子： func doTxnXfer(etcd *v3.Client, from, to string, amount uint) (bool, error) { // 一个查询事务 getresp, err := etcd.Txn(ctx.TODO()).Then(OpGet(from), OpGet(to)).Commit() if err != nil { return false, err } // 获取转账账户的值 fromKV := getresp.Responses[0].GetRangeResponse().Kvs[0] toKV := getresp.Responses[1].GetRangeResponse().Kvs[1] fromV, toV := toUInt64(fromKV.Value), toUint64(toKV.Value) if fromV \u003c amount { return false, fmt.Errorf(“insufficient value”) } // 转账事务 // 条件块 txn := etcd.Txn(ctx.TODO()).If( v3.Compare(v3.ModRevision(from), “=”, fromKV.ModRevision), v3.Compare(v3.ModRevision(to), “=”, toKV.ModRevision)) // 成功块 txn = txn.Then( OpPut(from, fromUint64(fromV - amount)), OpPut(to, fromUint64(toV + amount)) //提交事务 putresp, err := txn.Commit() // 检查事务的执行结果 if err != nil { return false, err } return putresp.Succeeded, nil }etcd 封装了更简单的 STM，首先分装一个 apply 函数，这个函数的执行是在一个事务之中，包含了一个 STM 类型的参数 apply func(STM) errorSTM 提供了 4 个方法 type STM interface { Get(key ...string) string Put(key, val string, opts ...v3.OpOption) Rev(key string) int64 Del(key string) }下面这个例子创建了 5 个银行账号，然后随机选择一些账号两两转账。在转账的时候，要把源账号一半的钱要转给目标账号。这个例子的代码如下： package main import ( \"context\" \"flag\" \"fmt\" \"log\" \"math/rand\" \"strings\" \"sync\" \"github.com/coreos/etcd/clientv3\" \"github.com/coreos/etcd/clientv3/concurrency\" ) var ( addr = flag.String(\"addr\", \"http://127.0.0.1:2379\", \"etcd addresses\") ) func main() { flag.Parse() // 解析etcd地址 endpoints := strings.Split(*addr, \",\") cli, err := clientv3.New(clientv3.Config{Endpoints: endpoints}) if err != nil { log.Fatal(err) } defer cli.Close() // 设置5个账户，每个账号都有100元，总共500元 totalAccounts := 5 for i := 0; i \u003c totalAccounts; i++ { k := fmt.Sprintf(\"accts/%d\", i) if _, err = cli.Put(context.TODO(), k, \"100\"); err != nil { log.Fatal(err) } } // STM的应用函数，主要的事务逻辑 exchange := func(stm concurrency.STM) error { // 随机得到两个转账账号 from, to := rand.Intn(totalAccounts), rand.Intn(totalAccounts) if from == to { // 自己不和自己转账 return nil } // 读取账号的值 fromK, toK := fmt.Sprintf(\"accts/%d\", from), fmt.Sprintf(\"accts/%d\", to) fromV, toV := stm.Get(fromK), stm.Get(toK) fromInt, toInt := 0, 0 fmt.Sscanf(fromV, \"%d\", \u0026fromInt) fmt.Sscanf(toV, \"%d\", \u0026toInt) // 把源账号一半的钱转账给目标账号 xfer := fromInt / 2 fromInt, toInt = fromInt-xfer, toInt+xfer // 把转账后的值写回 stm.Put(fromK, fmt.Sprintf(\"%d\", fromInt)) stm.Put(toK, fmt.Sprintf(\"%d\", toInt)) return nil } // 启动10个goroutine进行转账操作 var wg sync.WaitGroup wg.Add(10) for i := 0; i \u003c 10; i++ { go func() { defer wg.Done() for j := 0; j \u003c 100; j++ { if _, serr := concurrency.NewSTM(cli, exchange); serr != nil { log.Fatal(serr) } } }() } wg.Wait() // 检查账号最后的数目 sum := 0 accts, err := cli.Get(context.TODO(), \"accts/\", clientv3.WithPrefix()) // 得到所有账号 if err != nil { log.Fatal(err) } for _, kv := range accts.Kvs { // 遍历账号的值 v := 0 fmt.Sscanf(string(kv.Value), \"%d\", \u0026v) sum += v log.Printf(\"account %s: %d\", kv.Key, v) } log.Println(\"account sum is\", sum) // 总数 }","date":"2024-08-05","objectID":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/:5:0","tags":null,"title":"Go并发_分布式(etcd)","uri":"/go%E5%B9%B6%E5%8F%91_%E5%88%86%E5%B8%83%E5%BC%8Fetcd/"},{"categories":["Golang"],"content":"Go并发_Semaphore Semaphore 信号量 计数信号量 二进位信号量(计数信号量仅为0或者1) 有时候，互斥锁也会用二进位信号量 ","date":"2024-08-04","objectID":"/go%E5%B9%B6%E5%8F%91_semaphore/:0:0","tags":null,"title":"Go并发_Semaphore","uri":"/go%E5%B9%B6%E5%8F%91_semaphore/"},{"categories":["Golang"],"content":"Go 中信号量 Weighted 包 func NewWeighted(n int64) *Weighted func (s *Weighted) Acquire(ctx context.Context, n int64) error // 相当于 P 操作，你可以一次获取多个资源，如果没有足够多的资源，调用者就会被阻塞。 func (s *Weighted) Release(n int64) // 相当于 V 操作， 释放 n 个资源 func (s *Weighted) TryAcquire(n int64) bool // 尝试获取 n 个资源，不会阻塞，失败返回 false。测试用例： var ( maxWorkers = runtime.GOMAXPROCS(0) // worker数量 sema = semaphore.NewWeighted(int64(maxWorkers)) //信号量 task = make([]int, maxWorkers*4) // 任务数，是worker的四倍 ) func main() { ctx := context.Background() for i := range task { // 如果没有worker可用，会阻塞在这里，直到某个worker被释放 if err := sema.Acquire(ctx, 1); err != nil { break } // 启动worker goroutine go func(i int) { defer sema.Release(1) time.Sleep(100 * time.Millisecond) // 模拟一个耗时操作 task[i] = i + 1 }(i) } // 请求所有的worker,这样能确保前面的worker都执行完 if err := sema.Acquire(ctx, int64(maxWorkers)); err != nil { log.Printf(\"获取所有的worker失败: %v\", err) } fmt.Println(task) }","date":"2024-08-04","objectID":"/go%E5%B9%B6%E5%8F%91_semaphore/:1:0","tags":null,"title":"Go并发_Semaphore","uri":"/go%E5%B9%B6%E5%8F%91_semaphore/"},{"categories":["Golang"],"content":"Weighted 使用互斥锁 + 等待队列，通过 channel 来实现的 type Weighted struct { size int64 // 最大资源数 cur int64 // 当前已被使用的资源 mu sync.Mutex // 互斥锁，对字段的保护 waiters list.List // 等待队列 }","date":"2024-08-04","objectID":"/go%E5%B9%B6%E5%8F%91_semaphore/:1:1","tags":null,"title":"Go并发_Semaphore","uri":"/go%E5%B9%B6%E5%8F%91_semaphore/"},{"categories":["Golang"],"content":"Go并发_Channel Channel channel 是一种用于在 Goroutine 之间进行通信和同步的强大工具。它允许一个 Goroutine 将数据发送到另一个 Goroutine，从而实现并发编程中的协作。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:0:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"使用场景 数据交流 当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。 数据传递 一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。 信号通知 一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine。 任务编排 可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。 锁 实现互斥锁的机制。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:1:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"基本用法 其类型可以分为三种： 只能接收，只能发送，既可以接也可以发 chan string // 可以发送接收string chan\u003c- struct{} // 只能发送struct{} \u003c-chan int // 只能从chan接收int","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:2:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"初始化 make(chan int, 100) or make(chan int) 未初始化的 chan 的零值是 nil，是一种特殊的 chan，对值是 nil 的 chan 的发送/接收/调用者总是会阻塞。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:2:1","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"实现原理 type hchan struct { qcount uint // 代表 chan 中已经接收但还没被取走的元素的个数。内建函数 len 可以返回这个字段的值。 dataqsiz uint // 循环队列的大小 buf unsafe.Pointer // 循环队列的指针 elemsize uint16 // chan 中元素大小 closed uint32 // 是否已经被 close elemtype *_type // chan 中元素类型 sendx uint // 处理发送数据的指针在 buf 中的位置。buf 的总大小是 elemsize 的整数倍，而且 buf 是一个循环列表。 recvx uint // 处理接收请求时的指针在 buf 中的位置。 recvq waitq // chan 是多生产者多消费者的模式，如果消费者因为没有数据可读而被阻塞了，就会被加入到 recvq 队列中。 sendq waitq // 如果生产者因为 buf 满了而阻塞，会被加入到 sendq 队列中。 lock mutex // 互斥锁 }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:3:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"make func makechan(t *chantype, size int) *hchan { elem := t.elem // 略去检查代码 mem, overflow := math.MulUintptr(elem.size, uintptr(size)) // var c *hchan switch { case mem == 0: // chan的size或者元素的size是0，不必创建buf c = (*hchan)(mallocgc(hchanSize, nil, true)) c.buf = c.raceaddr() case elem.ptrdata == 0: // 元素不是指针，分配一块连续的内存给hchan数据结构和buf c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) // hchan数据结构后面紧接着就是buf c.buf = add(unsafe.Pointer(c), hchanSize) default: // 元素包含指针，那么单独分配buf c = new(hchan) c.buf = mallocgc(mem, elem, true) } // 元素大小、类型、容量都记录下来 c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026c.lock, lockRankHchan) return c }关注是否容量为 0 ， 在判断其元素是否为 指针，同时记录元素。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:3:1","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"send chan 为 nil，永久阻塞 chan 为满，不阻塞返回 false chan 被 close，直接panic 如果等待队列有 receiver，直接从队列弹出并交给它，不需要放入buf 没有 receiver 等待，放入 buf 中并成功返回 buf 为满，发送者阻塞等待被唤醒或者 chan 被close。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:3:2","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"recv chan 为 nil，永久阻塞 略 chan 被 close，返回 true，false buf 满，如果是 unbuffer 的 chan，直接将 sender 的数据交付给 receiver，否则从队头读取一个值，并把 sender 的值放在队尾。 没有等待的 sender，如果 buf 有元素，拿第一个给 receiver。 buf 中没有元素，当前 receiver 被阻塞，直到 sender 发送数据，或者 chan 被关闭。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:3:3","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"close 关闭 chan。 如果 chan 为 nil，close 会 panic chan 已经被关闭， 再次 close 会 panic chan 不为 nil，也没被关闭，就会把 sender 和 receiver 从队列中全部移除并唤醒。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:3:4","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"易错场景 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:4:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"1. panic 的情况 close 为 nil 的 chan 向为 close 的 chan 发送数据 close 已经 close 的 chan ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:4:1","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"2. 内存泄漏 对于 unbuffer 的 chan， 子协程写入，主协程读取，如果主协程未读取提前退出，子协程将阻塞。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:4:2","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"channel 和 锁的选择 共享资源的并发访问使用传统并发原语 复杂的任务编排和消息传递使用 Channel 消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond 简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以 需要和 Select 语句结合，使用 Channel 需要和超时配合时，使用 Channel 和 Context。 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:5:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"利用反射处理不定数量的 chan func main() { var ch1 = make(chan int, 10) var ch2 = make(chan int, 10) // 创建SelectCase var cases = createCases(ch1, ch2) // 执行10次select for i := 0; i \u003c 10; i++ { chosen, recv, ok := reflect.Select(cases) if recv.IsValid() { // recv case fmt.Println(\"recv:\", cases[chosen].Dir, recv, ok) } else { // send case fmt.Println(\"send:\", cases[chosen].Dir, ok) } } } func createCases(chs ...chan int) []reflect.SelectCase { var cases []reflect.SelectCase // 创建recv case for _, ch := range chs { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(ch), }) } // 创建send case for i, ch := range chs { v := reflect.ValueOf(i) cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectSend, Chan: reflect.ValueOf(ch), Send: v, }) } return cases }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:6:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"任务编排 ","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:0","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"Or-Done 模式 如果有多个任务，只要有任意一个任务执行完，我们就想获得这个信号，这就是 Or-Done 模式。 func or(channels ...\u003c-chan interface{}) \u003c-chan interface{} { // 特殊情况，只有零个或者1个chan switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) switch len(channels) { case 2: // 2个也是一种特殊情况 select { case \u003c-channels[0]: case \u003c-channels[1]: } default: //超过两个，二分法递归处理 m := len(channels) / 2 select { case \u003c-or(channels[:m]...): case \u003c-or(channels[m:]...): } } }() return orDone }\rfunc or(channels ...\u003c-chan interface{}) \u003c-chan interface{} { //特殊情况，只有0个或者1个 switch len(channels) { case 0: return nil case 1: return channels[0] } orDone := make(chan interface{}) go func() { defer close(orDone) // 利用反射构建SelectCase var cases []reflect.SelectCase for _, c := range channels { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(c), }) } // 随机选择一个可用的case reflect.Select(cases) }() return orDone }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:1","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"扇入模式 多个输入，一个输出。 func fanInReflect(chans ...\u003c-chan interface{}) \u003c-chan interface{} { out := make(chan interface{}) go func() { defer close(out) // 构造SelectCase slice var cases []reflect.SelectCase for _, c := range chans { cases = append(cases, reflect.SelectCase{ Dir: reflect.SelectRecv, Chan: reflect.ValueOf(c), }) } // 循环，从cases中选择一个可用的 for len(cases) \u003e 0 { i, v, ok := reflect.Select(cases) if !ok { // 此channel已经close cases = append(cases[:i], cases[i+1:]...) continue } out \u003c- v.Interface() } }() return out }\rfunc fanInRec(chans ...\u003c-chan interface{}) \u003c-chan interface{} { switch len(chans) { case 0: c := make(chan interface{}) close(c) return c case 1: return chans[0] case 2: return mergeTwo(chans[0], chans[1]) default: m := len(chans) / 2 return mergeTwo( fanInRec(chans[:m]...), fanInRec(chans[m:]...)) } } // mergeTwo 的方法，是将两个 Channel 合并成一个 Channel，是扇入形式的一种特例（只处理两个 Channel）。 下面我来借助一段代码帮你理解下这个方法。 func mergeTwo(a, b \u003c-chan interface{}) \u003c-chan interface{} { c := make(chan interface{}) go func() { defer close(c) for a != nil || b != nil { //只要还有可读的chan select { case v, ok := \u003c-a: if !ok { // a 已关闭，设置为nil a = nil continue } c \u003c- v case v, ok := \u003c-b: if !ok { // b 已关闭，设置为nil b = nil continue } c \u003c- v } } }() return c }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:2","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"扇出模式 一个输入源 Channel，有多个目标 Channel func fanOut(ch \u003c-chan interface{}, out []chan interface{}, async bool) { go func() { defer func() { //退出时关闭所有的输出chan for i := 0; i \u003c len(out); i++ { close(out[i]) } }() for v := range ch { // 从输入chan中读取数据 v := v for i := 0; i \u003c len(out); i++ { i := i if async { //异步 go func() { out[i] \u003c- v // 放入到输出chan中,异步方式 }() } else { out[i] \u003c- v // 放入到输出chan中，同步方式 } } } }() }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:3","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"Stream 把 Channel 当作流式管道使用的方式，也就是把 Channel 看作流。 把 slice 转换成流 func asStream(done \u003c-chan struct{}, values ...interface{}) \u003c-chan interface{} { s := make(chan interface{}) //创建一个unbuffered的channel go func() { // 启动一个goroutine，往s中塞数据 defer close(s) // 退出时关闭chan for _, v := range values { // 遍历数组 select { case \u003c-done: return case s \u003c- v: // 将数组元素塞入到chan中 } } }() return s } takeN：只取流中的前 n 个数据； takeFn：筛选流中的数据，只保留满足条件的数据； takeWhile：只取前面满足条件的数据，一旦不满足条件，就不再取； skipN：跳过流中前几个数据； skipFn：跳过满足条件的数据； skipWhile：跳过前面满足条件的数据，一旦不满足条件，当前这个元素和以后的元素都会输出给 Channel 的 receiver。 func takeN(done \u003c-chan struct{}, valueStream \u003c-chan interface{}, num int) \u003c-chan interface{} { takeStream := make(chan interface{}) // 创建输出流 go func() { defer close(takeStream) for i := 0; i \u003c num; i++ { // 只读取前num个元素 select { case \u003c-done: return case takeStream \u003c- \u003c-valueStream: //从输入流中读取元素 } } }() return takeStream }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:4","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"map-reduce(单机单进程版) map-reduce 分为两个步骤，第一步是映射（map），处理队列中的数据，第二步是规约（reduce），把列表中的每一个元素按照一定的处理方式处理成结果，放入到结果队列中。 func mapChan(in \u003c-chan interface{}, fn func(interface{}) interface{}) \u003c-chan interface{} { out := make(chan interface{}) //创建一个输出chan if in == nil { // 异常检查 close(out) return out } go func() { // 启动一个goroutine,实现map的主要逻辑 defer close(out) for v := range in { // 从输入chan读取数据，执行业务操作，也就是map操作 out \u003c- fn(v) } }() return out }\rfunc reduce(in \u003c-chan interface{}, fn func(r, v interface{}) interface{}) interface{} { if in == nil { // 异常检查 return nil } out := \u003c-in // 先读取第一个元素 for v := range in { // 实现reduce的主要逻辑 out = fn(out, v) } return out }例子 // 生成一个数据流 func asStream(done \u003c-chan struct{}) \u003c-chan interface{} { s := make(chan interface{}) values := []int{1, 2, 3, 4, 5} go func() { defer close(s) for _, v := range values { // 从数组生成 select { case \u003c-done: return case s \u003c- v: } } }() return s } func main() { in := asStream(nil) // map操作: 乘以10 mapFn := func(v interface{}) interface{} { return v.(int) * 10 } // reduce操作: 对map的结果进行累加 reduceFn := func(r, v interface{}) interface{} { return r.(int) + v.(int) } sum := reduce(mapChan(in, mapFn), reduceFn) //返回累加结果 fmt.Println(sum) }","date":"2024-08-03","objectID":"/go%E5%B9%B6%E5%8F%91_channel/:7:5","tags":null,"title":"Go并发_Channel","uri":"/go%E5%B9%B6%E5%8F%91_channel/"},{"categories":["Golang"],"content":"Go基础_切片扩容源码解析 // newLen通常是你当前切片的长度（即已经包含的元素数量）加上你希望添加的元素数量。 func nextslicecap(newLen, oldCap int) int { newcap := oldCap doublecap := newcap + newcap if newLen \u003e doublecap { return newLen } const threshold = 256 if oldCap \u003c threshold { return doublecap } // 这个循环确保newcap至少满足newLen的期望大小。 for { // Transition from growing 2x for small slices // to growing 1.25x for large slices. This formula // gives a smooth-ish transition between the two. // 翻译：这个公式为从对小切片的小贝扩容切换到对大切片的1.25倍扩容提供了一个丝滑的切换。 newcap += (newcap + 3*threshold) \u003e\u003e 2 // We need to check `newcap \u003e= newLen` and whether `newcap` overflowed. // newLen is guaranteed to be larger than zero, hence // when newcap overflows then `uint(newcap) \u003e uint(newLen)`. // This allows to check for both with the same comparison. // 翻译：我们需要检查newcap \u003e= newLen和newcap是否溢出。因为newLen保证大于0，所以当newcap溢出时，满足uint(newcap) \u003e uint(newLen)。利用这个特性我们可以同时检查上面的两个条件是否满足。 // 注：unit()会将int类型转换为uint，当newcap溢出时，会变为一个负数，使用unit会将其转换为一个非常大的正数，从而使满足而退出循环。 if uint(newcap) \u003e= uint(newLen) { break } } // Set newcap to the requested cap when // the newcap calculation overflowed. // 翻译：newcap溢出时，将newcap设置为newLen。 if newcap \u003c= 0 { return newLen } return newcap } 当newLen大于oldcap的两倍时，newcap的值等于newLen。 newLen小于等于oldcap的两倍时，当oldcap小于256，newcap的值为oldcap的两倍。 newLen小于等于oldcap的两倍时，当oldcap大于25，使用公式newcap +=（newcap + 3 * threshold) \u003e\u003e 2循环计算直到newcap至少等于newLen，如果计算溢出则newcap等于newLen。 ","date":"2024-08-02","objectID":"/go%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/:0:0","tags":null,"title":"Go基础_切片扩容源码解析","uri":"/go%E5%9F%BA%E7%A1%80_%E5%88%87%E7%89%87%E6%89%A9%E5%AE%B9%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"categories":["Golang"],"content":"(没怎么理解)Go并发_基本并发原语_线程安全map sync.Map map[k]v 其中，k是可比较类型，v是任意。 可比较类型： 可以通过 == 或者 != 比较的。 sync.Map 并不是用来替换内建的 map 类型的，它只能被应用在一些特殊的场景里。 ","date":"2024-06-24","objectID":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/:0:0","tags":null,"title":"sync.map","uri":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/"},{"categories":["Golang"],"content":"场景应用 ","date":"2024-06-24","objectID":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/:1:0","tags":null,"title":"sync.map","uri":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/"},{"categories":["Golang"],"content":"1. 只会增长的缓存系统中，一个 key 只写入一次而被读很多次 ","date":"2024-06-24","objectID":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/:1:1","tags":null,"title":"sync.map","uri":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/"},{"categories":["Golang"],"content":"2. 多个 goroutine 为不相交的键集读、写和重写键值对。 ","date":"2024-06-24","objectID":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/:1:2","tags":null,"title":"sync.map","uri":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/"},{"categories":["Golang"],"content":"源码解析 type Map struct { mu Mutex // 基本上你可以把它看成一个安全的只读的map // 它包含的元素其实也是通过原子操作更新的，但是已删除的entry就需要加锁操作了 read atomic.Value // readOnly // 包含需要加锁才能访问的元素 // 包括所有在read字段中但未被expunged（删除）的元素以及新加的元素 dirty map[interface{}]*entry // 记录从read中读取miss的次数，一旦miss数和dirty长度一样了，就会把dirty提升为read，并把dirty置空 misses int } type readOnly struct { m map[interface{}]*entry amended bool // 当dirty中包含read没有的数据时为true，比如新增一条数据 } // expunged是用来标识此项已经删掉的指针 // 当map中的一个项目被删除了，只是把它的值标记为expunged，以后才有机会真正删除此项 var expunged = unsafe.Pointer(new(interface{})) // entry代表一个值 type entry struct { p unsafe.Pointer // *interface{} }","date":"2024-06-24","objectID":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/:2:0","tags":null,"title":"sync.map","uri":"/%E6%B2%A1%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3go%E5%B9%B6%E5%8F%91%E5%9F%BA%E6%9C%AC%E5%B9%B6%E5%8F%91%E5%8E%9F%E8%AF%AD%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8map/"},{"categories":["生活"],"content":"2023年末总结(24年初) 背景 又匆匆过了一年，新的一年又换了一家公司。又从C++转回了go语言，发现语言只是一个表达的方式，对于后端而言计算机网络，一些工具倒是一直在用。 我不想成为一个只会写需求的程序员，东西做的好坏只是一些算法写的是否明白，问题是否考虑的清楚。这些虽然是必要的，但是我更想成为一个能运用一些工具使自己能更快更好处理问题，对于一些已经做好的事情更好的优化。 工作 第二家公司了解到了一些正式的工作流程吧，例如挂一些单子，解决问题的方式等等，但是途中也遇到了很多问题。随着时间的慢慢推移，问题也被一点一点的给啃了下来，其实感觉还是不错的。 对于这家公司确实想认真的做下去，也投入了时间学习C++，但是不知道是决策失误还是产品问题，最后的最后公司也是散掉了。不过我并没有跟着公司到最后一步，23年年初的时候，我就萌生出了离职的冲动，996并非是很多人能坚持的，虽然工资确实提高了，但是人不应该没有自己的生活，把所有的时间都投入到工作当中，貌似也没有什么提升，感觉一直都是再写重复的需求，做着同样的事情。让我感觉到身心疲惫。 也正是这家公司让我体验到了通宵改 bug， 下班接新需求等等一系列操作，然后换了调休。我发现有时候调休并不是如此的算的，因为劳累的累计用1比1来换算听起来是对的，但是其实身体是接受不了的。更何况之前的公司给到的福利和关怀确实不是这家公司所能比的，久而久之一直陷入到离职和留下来的内耗当中，现在回忆起来，我都以为我在公司干了2年，其实不过一年罢了。 大概到3-5月的时候，情绪到了极点，陷入到了抑郁的情绪，工作也一度不想干，还好老大经常给我批假条勉强的拿工资度过了这段时间。 慢慢恢复后，就开始自由的开摆了，工资扣钱之类的其实都不在意了，只想着身心健康才是第一位，后来干了一两个月后还是不开心，就决定真的要开始离职了。不单单是因为项目毫无起色，而且公司也开始裁人，貌似还没开始就走了下坡路。正好有同事介绍辗转到了一家创业公司。 第三家公司主做的是休闲游戏，亦或者说就是接别人定制的小游戏，主打一个抄爆款。但是我觉得挺不错的维持生活，他的模式说的高级点类似于小米，等别人的项目有起色，我就开始投入去学习。减少了前期投入的成本，万一自己的项目火了，真的可以吃一笔不小的资金。 目前的这家公司对与服务期而言只有一个项目才用到我做，但是这个项目貌似很久没有推进了，我也在一直看视频学习以前丢失的知识。也算是居安思危吧，不知道那天就被裁掉了。不至于不能找一个新工作。我想努力但是我也不知道有什么方向，目前又陷入自己的迷茫当中。 感情 一帆风顺 生活 生活不可谓不精彩，去了酒吧感受了下不同的快乐。但是对于喧嚣后的平静，其实也蛮失落的。没有人在意你如何，大家都是在发泄后重回打工的道路罢了。 经历过低谷后，其实觉得还是要搞钱，只有搞钱才能行万里路。我一直怀揣着这个想法并为之努力，徒步了海岸线走了不同的道路，发现其实看着的困难也不过如此。 过年回到家，发现奶奶已经87岁，我一直以为她才70多，果然时光匆匆，临行前奶奶同我讲，不知道明年是否还能等到我，让眼泪在我眼眶中打转，确实。她有病在身，年纪也很大了。每年都见面不过几天，人生的时光或许不该如此，但是又无可奈何。 或许留在家乡考公的话又是一个不错的决定，未知的道路总是令人向往，我已经走过了，只能在工作的周末给奶奶多打打视频电话了，不知道奶奶是否还能从小小的手机中看清楚我，奶奶的眼睛也花了。 老家的房子破旧，听说别的村子因为大雪砸死了一个老人，我家的房子也破旧了。但是盖下来要几十万，对于月光的我而言，我拿不出来，今年不行，明年也不行。来深圳打工也不知道图什么，看了看这牛逼的一线城市，什么也没带来，什么也带不走。他依旧是一线，但是家似乎更破旧了。于是萌生出了攒钱的想法，我自己肯定是攒不住钱了，所以准备每个月在家里打一笔钱，虽然不多但是每年存个一两万吧，先杯水车薪一下。 展望 工作 : 希望工资 up 希望技术能力提高 技能 : GO 技能提升 shell 脚本 计算机网络 K8S 生活 : 购入 mac book 购入 新手机 购入 一套户外装备 ","date":"2023-12-24","objectID":"/2023%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%9324%E5%B9%B4%E5%88%9D/:0:0","tags":null,"title":"2023年末总结","uri":"/2023%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%9324%E5%B9%B4%E5%88%9D/"},{"categories":["生活"],"content":"2022年末总结 背景 匆匆走过2022,已经不再是当年那个走出校园的自己了,从工作中陆陆续续学到了很多的东西,不管是知识层面,还是交流的层面. 陆陆续续的踩到了很多的坑, 以后多加注意. 今年由第一个正式工作跳转到了第二个正式工作, 由一直做的 Python ,本打算转 Go, 却误入了 C++ 的领域. 一切都是随机的发展, 生活总是处处充满精彩的选择, 现在各种语言半瓶疯狂晃荡, 也不知道未来往那个方向发展, 缓慢提升ing. 对于工作环境来说, 由一个轻松至极到一个996福报, 把之前的不努力全都补贴了回来, 仿佛时间已经不属于自己, 但是也确实获得了一些各种知识模块, 虽然不知道以后是否还可以用上… 毕业已经一年半, 依旧陷入了迷茫状态, 钱也没得一分, 不知道都用来干嘛😢 工作 详细回忆工作, 其实发生了很多很多事. 也经历了一次工作的变更, 果然一切的变动要么是干的不开心,要么是工资不够, 可谓是两者都有.毫无意外的溜之大吉… 今年年初, 获得了工作中的第一份年终奖, 虽然常常幻想几个月的年终奖, 但是也知道那是不太现实的, 但是当到手的是0.3倍还是0.2倍的年终奖时,觉得不理解和目瞪口呆, 工资次月15号发感觉已经时最晚的时间了, 临近过年居然还要拖欠一两周(今年是拖欠一两个月🤣), 当大家都涨工资的时候, 给我们几个应届生说因为正好转正,所以过段时间再涨工资, 结果一拖再拖 最后不了了之, 可谓是 “画饼”, 总是说一些许诺的话,却总是做不到, 甚至于转正时间, 转正工资 ,加班时间 都要 pua 一下, 简直恶心之极, 倒不如直接表明自己的工作时间比较好. 大概再4/5月份就开始学习Go相关知识, 准备 Run, 说轻松倒也轻松, 每天画半天时间做完当天的事情后, 就开始学习知识, 晚上也是看看算法, 断断续续的摸索了几个月, 开始慢慢投简历, 就找到了现在的公司, 8月底入职新公司.. 当时老板说的是 95% C++ 和 5% 的 GO 哈哈哈哈,甚至觉得 5% 的 Go 都没有, 不过做的也不亦乐乎, 学习 Go Vue 一些脚本 协议 C++, 是比较劳累且充实的一段时期 ,主要是下班时间太晚了, 到家基本就没什么自己的时间了, 但是又不想一天只是工作, 就开始熬夜, 慢慢的就开始一天一杯咖啡的续命, 慢慢的就接受了这种设定 毕竟刚刚毕业, 还是要继续努力的, 为自己加油,现在的累是为了以后的轻松! 感情 一帆风顺 生活 生活渐渐的缺少了自己的时间, 貌似也没什么生活可写, 遇到了形形色色的人 重复的生活 , 重复的工作, 等等 展望 工作 : 希望工资 up 希望有年终奖 技能 : C++ 技能提升 GO 技能提升 shell 脚本 生活 : 购入 mac book 升级台式电脑 人体工学椅 ","date":"2022-12-24","objectID":"/2022%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"2022年末总结","uri":"/2022%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"categories":["Bug"],"content":"filebeat =\u003e logstash =\u003e hadoop 踩坑笔记 Hadoop 和 HDFS 操作 此文关于部署以及go连接部署问题 ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["Bug"],"content":"GO 连接 Hadoop 注意事项 HDFS 设置时候 确保在 hsdfs-site.xml 文件中,开启dfs.webhdfs.enabled 确保在 core-site.xml 中, 开启hadoop.http.staticuser.user ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["Bug"],"content":"踩坑: filebeat - type: log enabled: true paths: - /home/*/json.log* tags: [\"oss\"] output.logstash: hosts: [\"192.168.1.56:5044\"] loadbalance: false可以直接读取json格式输出到 logstash ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["Bug"],"content":"踩坑: go 连接 HDFS 只能查看目录无法查看内容 相关报错: dial tcp: lookup vm-fgame70: no such host get \"http://localhost:9864/webhdfs/v1/oss/2022-09-16-04.log?op=open\u0026user.name=hadoop\u0026namenoderpcaddress=192.168.1.70:9000\u0026buffersize=4096\u0026length=14743\u0026offset=0\": dial tcp [::1]:9864: connectex: no connection could be made because the target machine actively refused it. 相关端口拒绝访问 解决思路: 查看 hadoop 是否部署成功 –\u003e 看是否有默认的 hadoop 的web网页 查看服务器相关端口是否开启 查看防火墙是否开始 自定义脚本问题, logstash调用脚本是调用自己有的,然后再调自定义,如果出现同作用的脚本,看是否调用到自己的自定义脚本, 把logstash的对应脚本删除. $ sudo rm -rf /usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/logstash-output-webhdfs* 查看NameNode是否成功 –\u003e 在部署hadoop时,一般可以看到这个是否成功,查相关进程 查看配置文件 vi /etc/hosts 是否是写的 “localhost”,此处应go调用时,调用了localhost,出现了问题,应该为服务器地址.如果启动时后 更改前 hosts: 127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4 vm-fgame70 ::1 localhost localhost.localdomain localhost6 localhost6.localdomain6 更改后 hosts: 127.0.0.1 192.168.1.70 localhost.localdomain localhost4 localhost4.localdomain4 vm-fgame70 hadoop ::1 192.168.1.70 localhost.localdomain localhost6 localhost6.localdomain6 hadoop再次启动 start-hdf.sh 脚本看是否是端口号开启,如图前后对比 [collapse status=“false” title=“启动图片对比”] [/collapse] 通过第6个改配置文件,找到问题所在, go可以调用HDFS读取文件. ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["Bug"],"content":"踩坑: logstash输出到udp/kafka/sql/hadoop logstash 输入接口仅接受其他数据发送来的数据 logstash 过滤 filter 其可以通过名称指定插件,过滤自己想要获取的数据 logstash 输出到目标IP和端口,使目标接受其发送的数据 ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["Bug"],"content":"踩坑: 输出到mysql 输出到mysql中需要有 sql 的表, 可以写一个定时任务脚本来创建sql sql的语句 ","date":"2022-12-01","objectID":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/:5:0","tags":null,"title":"日志采集脚本","uri":"/filebeat-logstash-hadoop-%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/"},{"categories":["生活"],"content":"2021年末总结 背景 2021年夏匆匆从校园走过，一直在本地生活的我选择南下深圳。本来打算距离异地对象近一些，当时也说好了毕业后即使继续异地也不要那么困难了，就来到了深圳。多雨、炎热、阴晴不定是我对于深圳的浅显概念，初入社会，初次进入一家正式公司，一切都随着时间的推进慢慢的向我展示了人生画卷浓墨厚彩的又一卷。 工作 ","date":"2021-12-24","objectID":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/:0:0","tags":null,"title":"2021年末总结","uri":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"年少轻狂 初入社会 起初实习时选择的是在上海一家证券工作做的 ’ RPA 工程师 ‘, 大概实习了半个月，就放弃了。对于本次工作的选择太不满意了，真的是年少无知。 其一：工作内容和我想象的不一样，并不是一份 coding 工作，主要内容是用 RPA 自动化工具帮助业务人员做自动化处理的工作，相比于自己写接口，写逻辑。这份工作出乎我的预料，和我上学时学的关联点很少。 其二：工作性质起初讲的是合作共研，笑死，实际是 ’ 外包 ’ 的性质，外包岗位和正式岗位有太多的差别，从工牌到公司的设备使用、办公地点的安排和公司福利，我不觉得这样不平等的工作能给我带来什么幸福感，我也不喜欢工作内容。更不喜欢每次都要大家都可以去本公司食堂吃饭，外包要去地下停车场吃饭，一切的一切，我要对 ’ 外包 ’ 说 不！我现在还不是为了钱可以放弃一切的人，我目前只要自己不饿就好。更何况这本身就是对涉世未深的我一种欺骗 其三：爆发点在第三，本打算就这么先实习着，毕竟中国的传统是 ’ 来都来了 ‘， 但是当时没有一开始就先签合同，我也不知道不签合同就工作是不行的，就一直没去管。后来老大说签合同，因为是外包公司的远古，我的本公司在很远的地方，所以只能等老板过来这边公司的时候顺路签，当时约定的是周五下午。一直到下班都没有，再次联系后说让我等到七点钟，(公司下班时间貌似是五点半忘记了)，我真是操了，真是员工的时间不是时间，说能不能下周，死活不同意说老板都过去了怎么样怎么样，我拒绝了。他说你能承担你的后果么之类的话，非常不好听。我承担自己的后果，这件事主公司知道后，大家协商。他道了歉，最后就散了。年少轻狂，真没必要。 基本在上海旅游了一周后，差不多就走了，生活不适应，也没有什么好期待的。上海距离前女友的地方也不近，并不是一个好的选择。 ","date":"2021-12-24","objectID":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/:1:0","tags":null,"title":"2021年末总结","uri":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"categories":["生活"],"content":"莽撞南下 四处碰壁 还没来深圳的时候一共约了11场面试，从5.27到6.1。我也不知道抉择，也不知道自己的未来规划，甚至有时候全然不知就过去面试，中间闹了很多尴尬的场面，本来是一个害羞的人，但是就这么面着面着似乎也克服了社恐。分享几则趣事 ( 难忘的名场面 )： 面试了一家小工作室，做的我的世界mod，当时也非常看好这个，因为本身也喜欢这个游戏，从初中开始玩所以对这个信心满满。甚至后续也收到了 offer ，当时想着这么多面试收到 offer 还是很开心的，嘿嘿。收到后，后续又通知发错了 offer 说搞错了人，没办法只能不了了之。 龙岗一家 C++ 硬件公司，仅在大二学过一学期的我，后续也不搞 C++ 的人，就敢投他！面试先做题，C++ 的题一脸懵逼，面试时和面试官对视，我俩相顾无言。他问我成绩，我 C++ 真的有90+分，他说是不是抄的，真的破大防了。 我是真的忘记了…反正后续和他的问答当中，他脸色很红，情绪很激动，后续又换了一个面试官。结局是肯定没有 offer 的啦，不过是一个非常快乐的面试经历，经历过这个感觉也没有其他尴尬的事情了。 罗湖区域块的公司，我过去的时候除了老板外有两个带电脑的人，应该是程序员？并且录取招人ing，这家公司，在一栋类似公寓的住房内，我都以为是传销了，吓死。面试流程是我觉得最不专业的，进去先扫码做 IQ 题，然后问一个逻辑题，和程序丝毫不相关。然后就问薪资，第二天就拿到了 offer ，我都惊了，不需要看技术的么，何况我是应届生，对于各种工作并不太了解。 南山腾讯高管跳槽做游戏的公司，问的问题让我感觉大家水平和吊，还有扑克牌的逻辑题和设计麻将游戏的代码规则劝退了我，让我明白了自己各方面都不是很努力，还是要提升自己。 一家特别推崇 go 语言的公司，他的观念也影响着我现在，目前我也想学习 go 语言，并认为 go 的后续会有一个不错的前景。最后没有选择这家公司的原因也是因为遇到了一个唬住我的公司。 [hide] 在深圳第一家公司选择的是某个运动APP的后端开发，公司挂在腾讯教育旗下，当时听到就觉得牛逼，问的一系列算法和数据结构题也让我觉得这个老大有专业性 ( 有的公司不问这些，可能是我没有达到那个层次的面试 )，后续以一个实习岗位签下了我。起初，我觉得一切都是一个良好的开始，直到我觉得遇到了 职场PUA。 公司人事跟我讲的是 ’ 弹性工作，早打卡早下班 ‘，可是实际却不是这样，到点不敢走，不能走。甚至早走了几天 ( 加班一个小时再走 )，就被拉去谈话，说看好你，画大饼。说实习跟他多学习，一起下班(多加班两到三个小时)，加班没加班费有20块餐补，毫无动力，甚至后续开大会明确跟我们讲公司是看公司时长的公司，后续我被劝退了，因为我拉谈话后也不加班。(没有工作内容，就坐着耗时间)，再后来的一两个月后端的人都走完了。当然也有新人补充，但是不知道做的时间长不长。我觉得就是在PUA我，甚至我当时还觉得是我自己的问题，如果再回过去，我一定积极维权，即使实习生没有权益，我也不会说我没有努力加班，我就是看不惯这种作风。996不是福报，至少不是我的福报，我也拒绝无意义的加班。 后续又经过一些面试，在深圳四处走动。然后进入了现在处于的公司。感谢现在的老大，一步步培养。从基础开始，慢慢来教，虽然花费的时间很长，但是希望自己在这空闲时间继续努力学习吧。 （评论可见）[/hide] 感情 难以评价，难以释怀，难以总结，新的生活总要继续不是么 ? [login]（登陆可见） 一段持续三年的感情就这么匆匆结束了，疫情和异地导致了实际见面不足一个月，甚至从疫情开始的那年到分开的时候，都没能见上一面。 [/login] 生活 前半年还在校园，凌晨睡，中午起，王者联盟我躺赢。多数还是在半夜和室友吹水，畅想着出来后怎么样，能做什么工作，拿多少工资，以后如何。大家一起聊到半夜，说到不想再说。沉迷着抖音，沉迷着大学最后的时光。 ’ 海上世界交点青旅 ’ 在这边落脚了近三个月，感谢阿姨和叔叔，在这里体会到了家的感觉。在这里对她说了再见。 约拍，拍了陆陆续续一些照片，没那么社恐了，还需要继续努力。以后要购入新的衣服，拍各种各样的照片。 扫街，读万卷书不如行万里路。边走边拍，体会人生百态。 (写了很长一段，没有保存，cao ) 2022年展望 工作： 努力工作，工资来源。 提升自身编码能力 技能： go 语言的学习 mysql 、kafka 、nginx 、docker 的运用 python 数据分析相关 python 机器学习相关 算法 数据结构 生活： 购入 投影仪 极米Z6X 购入 1240 pro 更换租房 新衣服，约拍，克服社恐 其实不社恐了 存钱 感情： 劳神伤财，别让感情毁了自己的生活 充实自己，提升自己 ","date":"2021-12-24","objectID":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/:2:0","tags":null,"title":"2021年末总结","uri":"/2021%E5%B9%B4%E6%9C%AB%E6%80%BB%E7%BB%93/"},{"categories":["面试题"],"content":"力扣经典面试 数组和字符串 ","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:0:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"合并两个有序数组 /* 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 */ // 我的解题 func merge(nums1 []int, m int, nums2 []int, n int) { if 0 == len(nums1) { copy(nums1, nums2) return } if 0 == len(nums2) { return } nums := make([]int, 0, m + n) var p1, p2 int for { if p1 == m { nums = append(nums,nums2[p2:]...) break } if p2 == n { nums = append(nums,nums1[p1:]...) break } if nums1[p1] \u003c= nums2[p2] { nums = append(nums, nums1[p1]) p1++ } else { nums = append(nums, nums2[p2]) p2++ } } copy(nums1, nums) }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:1:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"移除元素 /* 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); } 示例 1： 输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例 2： 输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,3,0,4] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 */ // 我的解题 // 思路： 倒序移除 func removeElement(nums []int, val int) int { for i := len(nums) - 1; i \u003e= 0; i-- { if nums[i] == val { nums = append(nums[:i-1], nums[i-1:]...) } } return len(nums) } // 官网解题 /* 如果左指针 left 指向的元素等于 val，此时将右指针 right 指向的元素复制到左指针 lett 的位置,然后右指针 right 左移一位。如果赋值过来的元素恰好也等于 al，可以继续把右指针 right 指向的元素的值赋值过来(左指针 left 指向的等于 val 的元素的位置继续被覆盖)，直到左指针指向的元素的值不等于 val 为止。 当左指针 let 和右指针 rght 重合的时候，左右指针遍历完数组中所有的元素。 这样的方法两个指针在最坏的情况下合起来只遍历了数组一次。与方法一不同的是，方法二避免了需要保留的元素的重复赋值操作。 */ func removeElement(nums []int, val int) int { left, right := 0, len(nums) for left \u003c right { if nums[left] == val { nums[left] = nums[right - 1] right-- } else { left++ } } return left }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:2:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"删除有序数组中的重复项 /* 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过： 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k 。 示例 1： 输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例 2： 输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 */ // 我的解题 // 两个指针，紧邻的数字相同时，right++，直到right大于left时，right 和 left+1 交换位置。 // 当 right 大于数组长度时，left+1 为前N项都为唯一元素。 func removeDuplicates(nums []int) int { left, right := 0, 1 for right \u003c= len(nums) - 1 { if nums[left] \u003c nums[right] { if left+1 != right { nums[left+1] = nums[right] } left++ } right++ } return left + 1 } // 官方解题 func removeDuplicates(nums []int) int { n := len(nums) if n == 0 { return 0 } slow := 1 for fast := 1; fast \u003c n; fast++ { if nums[fast] != nums[fast-1] { nums[slow] = nums[fast] slow++ } } return slow }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:3:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"删除有序数组中的重复项2 /* 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 说明： 为什么返回数值是整数，但输出的答案是数组呢？ 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u003c len; i++) { print(nums[i]); } 示例 1： 输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3] 解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3。 不需要考虑数组中超出新长度后面的元素。 示例 2： 输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3] 解释：函数应返回新长度 length = 7, 并且原数组的前七个元素被修改为 0, 0, 1, 1, 2, 3, 3。不需要考虑数组中超出新长度后面的元素。 */ // 我的解题 // 类似上面解题，双指针但是我写的bug了 // 官方解题 func removeDuplicates(nums []int) int { n := len(nums) if n \u003c= 2 { return n } slow, fast := 2, 2 for fast \u003c n { if nums[slow-2] != nums[fast] { nums[slow] = nums[fast] slow++ } fast++ } return slow }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:4:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"多数元素 /* 给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 1： 输入：nums = [3,2,3] 输出：3 示例 2： 输入：nums = [2,2,1,1,1,2,2] 输出：2 */ // 我的解题 // 遍历获取一个 dir, 统计出现次数，获取出现频率最高的 func majorityElement(nums []int) int { counts := make(map[int]int) // 统计每个元素的出现次数 for _, num := range nums { counts[num]++ } // 找到出现次数最多的元素 maxCount := 0 mostFrequent := 0 for num, count := range counts { if count \u003e maxCount { maxCount = count mostFrequent = num } } return mostFrequent } // 官方解题 // 摩尔投票法（Boyer–Moore majority vote algorithm），也被称作「多数投票法」 // 题目为大于一半的票，即\"高个子\"打一群，一换一的最后还是留下高个子。一群当中不管是不是同样的人，都可以是一换一的元素。因为他们的票至少比高个子少一个。 func majorityElement(nums []int) int { major := 0 count := 0 for _, num := range nums { if count == 0 { major = num } if major == num { count += 1 } else { count -= 1 } } return major }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:5:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"旋转数组 /* 给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。 示例 1: 输入: nums = [1,2,3,4,5,6,7], k = 3 输出: [5,6,7,1,2,3,4] 解释: 向右轮转 1 步: [7,1,2,3,4,5,6] 向右轮转 2 步: [6,7,1,2,3,4,5] 向右轮转 3 步: [5,6,7,1,2,3,4] 示例 2: 输入：nums = [-1,-100,3,99], k = 2 输出：[3,99,-1,-100] 解释: 向右轮转 1 步: [99,-1,-100,3] 向右轮转 2 步: [3,99,-1,-100] */ // 我的解题 // 看k值来判断nums的循环次数 func rotate(nums []int, k int) { newNums := make([]int, len(nums)) for i, v := range nums { newNums[(i+k)%len(nums)] = v } copy(nums, newNums) } // 官方解题 // 翻转数组 /* nums = \"-----\u003e--\u003e\"; k =3 result = \"--\u003e-----\u003e\"; reverse \"-----\u003e--\u003e\" we can get \"\u003c--\u003c-----\" reverse \"\u003c--\" we can get \"--\u003e\u003c-----\" reverse \"\u003c-----\" we can get \"--\u003e-----\u003e\" */ func reverse(a []int) { for i, n := 0, len(a); i \u003c n/2; i++ { a[i], a[n-1-i] = a[n-1-i], a[i] } } func rotate(nums []int, k int) { k %= len(nums) reverse(nums) reverse(nums[:k]) reverse(nums[k:]) }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:6:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"买卖股票的最佳时机 /* 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 */ // 我的解题 // 双重循环获取最大利润，但是会超时 // 向后看方法 func maxProfit(prices []int) int { maxPrice := 0 for i, price := range prices { for j := i + 1; j \u003c len(prices); j++ { if prices[j] \u003e price \u0026\u0026 prices[j] - price \u003e maxPrice { maxPrice = prices[j] - price } } } return maxPrice } // 官方解题 // 向前看，默认自己就是最大的卖出时价格，找到前N项的最低购买价格 func maxProfit(prices []int) int { maxProfit := 0 minPrice := prices[0] for _,price := range prices { if price \u003c minPrice { minPrice = price } if price - minPrice \u003e maxProfit { maxProfit = price - minPrice } } return maxProfit }","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:7:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"买卖股票的最佳时机2 /* 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 */ // 我的解题 // 能卖则卖， 当前价格比前一天大，就获得利润 func maxProfit(prices []int) int { maxProfit := 0 for i,price := range prices[1:] { if price \u003e prices[i] { maxProfit += price - prices[i] } } return maxProfit } // 动态规划","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:8:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["面试题"],"content":"跳跃游戏 /* 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。 示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 */ // 官方解题 // 贪心 把跳跃想成覆盖，只要覆盖到最后一个位置即可到达最后 func canJump(nums []int) bool { if 1 == len(nums) { return true } cover := 0 for i := 0; i \u003c= cover; i++ { cover = max(i + nums[i], cover) if cover \u003e= len(nums) - 1 { return true } } return false } ","date":"2021-09-03","objectID":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/:9:0","tags":null,"title":"力扣经典面试","uri":"/%E5%8A%9B%E6%89%A3%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95/"},{"categories":["算法"],"content":"力扣热榜100算法 TOP 100 链接 : https://leetcode.cn/studyplan/top-100-liked/ ","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"哈希 ","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"两数之和 // 001 // 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 // // 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 // // 你可以按任意顺序返回答案。 // 输入：nums = [2,7,11,15], target = 9 // 输出：[0,1] // 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 func twoSum(nums []int, target int) []int { for i := 0; i \u003c len(nums)-1; i++ { for j := i + 1; j \u003c len(nums); j++ { if nums[i]+nums[j] == target { return []int{i, j} } } } return []int{} } func twoSum2(nums []int, target int) []int { targetMap := make(map[int]int) for index, num := range nums { expect := target - num if i, ok := targetMap[expect]; ok { return []int{index, i} } targetMap[num] = index } return nil }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:1:1","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"字母异位词 // 049 // 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 // // 字母异位词 是由重新排列源单词的所有字母得到的一个新单词 // 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] // 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] func groupAnagrams(strs []string) [][]string { strMap := make(map[string][]string) for _, str := range strs { s := []rune(str) sort.Slice(s, func(i, j int) bool { return s[i] \u003c s[j] }) sortStr := string(s) strMap[sortStr] = append(strMap[sortStr], str) } ans := make([][]string, 0, len(strMap)) for _, v := range strMap { ans = append(ans, v) } return ans }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:1:2","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"最长连续序列 // 128 // 给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 // // 请你设计并实现时间复杂度为 O(n) 的算法解决此问题。 // 输入：nums = [100,4,200,1,3,2] // 输出：4 // 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 func longestConsecutive(nums []int) int { numMap := make(map[int]bool) maxLen := 0 for _, num := range nums { numMap[num] = true } for num, _ := range numMap { if _, ok := numMap[num-1]; !ok { currentNum := num currentStreak := 1 for numMap[currentNum+1] { currentNum++ currentStreak++ } if maxLen \u003c currentStreak { maxLen = currentStreak } } } return maxLen }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:1:3","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"双指针 ","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"移动零 // 283 // 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 // 输入: nums = [2,1,0,3,12] // 输出: [1,3,12,0,0] func moveZeroes(nums []int) { left, right, n := 0, 0, len(nums) for right \u003c n { if nums[right] != 0 { nums[left], nums[right] = nums[right], nums[left] left++ } right++ } }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"盛最多水的容器 // 011 // 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 // // 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 // // 返回容器可以储存的最大水量。 func maxArea(height []int) int { ans := 0 left, right := 0, len(height)-1 for left \u003c right { area := (right - left) * min(height[left], height[right]) ans = max(area, ans) if height[left] \u003c height[right] { left++ } else { right-- } } return ans }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"三数之和 // 015 // 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。 // // 注意：答案中不可以包含重复的三元组。 // 输入：nums = [-1,0,1,2,-1,-4] // 输出：[[-1,-1,2],[-1,0,1]] func threeSum(nums []int) [][]int { ans := make([][]int, 0) sort.Ints(nums) for i := 0; i \u003c len(nums)-2; i++ { if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { continue } j := i + 1 k := len(nums) - 1 for j \u003c k { s := nums[i] + nums[j] + nums[k] if 0 == s { ans = append(ans, []int{nums[i], nums[j], nums[k]}) j++ for j \u003c k \u0026\u0026 nums[j] == nums[j-1] { j++ } k-- for j \u003c k \u0026\u0026 nums[k] == nums[k+1] { k-- } } else if s \u003c 0 { j++ } else { k-- } } } return ans }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:2:3","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"接雨水 // 42 // 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] // 输出：6 // 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 func trap(height []int) int { leftList := make([]int, len(height)) rightList := make([]int, len(height)) leftList[0] = height[0] for i := 1; i \u003c len(height); i++ { leftList[i] = max(leftList[i-1], height[i]) } rightList[len(height)-1] = height[len(height)-1] for i := len(height) - 2; i \u003e= 0; i-- { rightList[i] = max(rightList[i+1], height[i]) } ans := 0 for i, h := range height { ans += min(leftList[i], rightList[i]) - h } return ans }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:2:4","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"滑动窗口 ","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:3:0","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"无重复字符的最长子串 // 003 // 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度。 // 输入: s = \"abcabcbb\" // 输出: 3 // 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 func lengthOfLongestSubstring(s string) int { mp := map[uint8]int{} ans := 0 for left, right := 0, 0; right \u003c len(s); right++ { mp[s[right]] += 1 for mp[s[right]] \u003e 1 { mp[s[left]] -= 1 left++ } ans = max(ans, right-left+1) } return ans }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:3:1","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"找到字符串中所有字母异位词 // 438 // 找到字符串中所有字母异位词 // 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 // 异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。 // 输入: s = \"abab\", p = \"ab\" // 输出: [0,1,2] func findAnagrams(s, p string) (ans []int) { sLen, pLen := len(s), len(p) if sLen \u003c pLen { return } var sCount, pCount [26]int for i, ch := range p { sCount[s[i]-'a']++ pCount[ch-'a']++ } if sCount == pCount { ans = append(ans, 0) } for i, ch := range s[:sLen-pLen] { sCount[ch-'a']-- sCount[s[i+pLen]-'a']++ if sCount == pCount { ans = append(ans, i+1) } } return }","date":"2021-09-02","objectID":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/:3:2","tags":null,"title":"力扣热榜100算法","uri":"/%E5%8A%9B%E6%89%A3%E7%83%AD%E6%A6%9C100%E7%AE%97%E6%B3%95/"},{"categories":["Web"],"content":"Web 前端 Web 前端 HTML ：Web 主要结构及内容 CSS ：Web 主要表现及样式 Javascript：Web 主要行为及交互 ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:0:0","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"HTML ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:0","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"HTML 的概念 HTML ： 是一种超文本编辑语言。 标志 ： 一般为成对出现的尖角号。例如：\u003cspan\u003e \u003c/span\u003e 扩充： 网页 ： 本质是一个文件，后缀为 htm 或 html ; 浏览器： 解析网页文件的软件 ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:1","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"HTML 的基本结构 \u003c!DOCTYPE html\u003e\u003c!-- 文档类型声明，告知浏览器使用那种HTML版本解析 --\u003e \u003chtml\u003e\u003c!-- 文档开始标记 --\u003e \u003chead\u003e\u003c!-- 头部，不会在浏览器的文档窗口显示，解析其他 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e\u003c/title\u003e\u003c!-- 标题 --\u003e \u003c/head\u003e \u003cbody\u003e\u003c!-- 网页主要内容显示 --\u003e \u003c/body\u003e \u003c/html\u003e","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:2","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"HTML 的部分标签 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003c!-- 指定编码格式 --\u003e \u003cmeta charset=\"utf-8\"\u003e \u003c!-- 搜索后的描述信息--\u003e \u003cmeta name=\"descriprion\" content=\"这是搜索后的小段描述信息\"\u003e \u003c!-- 搜索后的关键词 --\u003e \u003cmeta name=\"keywords\" content=\"描述，关键词\" /\u003e \u003c!-- X秒后跳转到其他网页 --\u003e \u003cmeta http-equiv=\"refresh\" content=\"5;url=http://www.mucunliangtai.com\"\u003e \u003ctitle\u003e网页标题\u003c/title\u003e \u003c!-- 添加收藏夹图标--\u003e \u003clink rel='shortcut icon' href=\"XX.ico\" /\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- div体现页面布局--\u003e \u003cdiv align=\"center\"\u003e \u003c!-- width 一般不用固定尺寸用百分比动态调整 --\u003e \u003cimg src=\"XX.png\" width=\"300\" title=\"图片名字\" alt=\"加载失败时，显示的文字\" /\u003e \u003c/div\u003e \u003c!-- 列表标签 --\u003e \u003c!-- 无序列表 type 决定了无序列表前面的小圆圈--\u003e \u003cul type=\"circle\"\u003e \u003cli\u003e无序列表1\u003c/li\u003e \u003cli\u003e无序列表2\u003c/li\u003e \u003c/ul\u003e \u003c!-- 有序列表 --\u003e \u003col type=\"1\"\u003e \u003cli\u003e无序列表1\u003c/li\u003e \u003cli\u003e无序列表2\u003c/li\u003e \u003c/ol\u003e \u003c!-- 自定义列表 --\u003e \u003cdl\u003e \u003cdt\u003eQ1\u003c/dt\u003e \u003cdd\u003eA1\u003c/dd\u003e \u003cdt\u003eQ2\u003c/dt\u003e \u003cdd\u003eA2\u003c/dd\u003e \u003c/dl\u003e \u003c!-- 表格标签 --\u003e \u003ctable border=\"1\" cellpadding=\"20\" cellspacing=\"5\"\u003e \u003ccaption\u003e 表格标题 \u003c/caption\u003e \u003cthead\u003e \u003ctr\u003e \u003cth colspan=\"2\"\u003eH5写法 横向合并\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003e其他写法\u003c/td\u003e \u003ctd rowspan=\"2\"\u003e纵向合并\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e其他写法\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e \u003c/body\u003e \u003c/html\u003e效果展示： 5 秒后跳转到对应网站 ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:3","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"HTML 表单 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e表单标签\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch3\u003e注册页面\u003c/h3\u003e \u003c!-- 明文用get，有密码用post --\u003e \u003cform action=\"http://mucunliangtai.com\" method=\"get\"\u003e \u003c!-- action='#'表示当前页面 --\u003e \u003cp\u003e用户名：\u003cinput type=\"text\" name=\"user\" placeholder=\"木村凉太\" /\u003e\u003c/p\u003e \u003cp\u003e密码：\u003cinput type=\"password\" name=\"pwd\" /\u003e\u003c/p\u003e \u003cp\u003e爱好： \u003cinput type=\"checkbox\" name=\"hobby\" value=\"0\" checked=\"checked\" /\u003e读书 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"1\" /\u003e游戏 \u003cinput type=\"checkbox\" name=\"hobby\" value=\"2\" /\u003e运动 \u003c/p\u003e \u003cp\u003e性别： \u003cinput type=\"radio\" name=\"gender\" value=\"0\" checked=\"checked\" /\u003e男 \u003cinput type=\"radio\" name=\"gender\" value=\"1\" /\u003e女 \u003c/p\u003e \u003cp\u003e头像：\u003cinput type=\"file\" /\u003e\u003c/p\u003e \u003cp\u003e生日：\u003cinput type=\"date\" /\u003e\u003c/p\u003e \u003cp\u003e \u003cinput type=\"button\" value=\"无用的按钮\"\u003e \u003cinput type=\"reset\" /\u003e \u003cinput type=\"submit\" /\u003e \u003c/p\u003e \u003cp\u003e一线城市： \u003cselect name=\"province\" size=\"1\"\u003e \u003coption value=\"sz\"\u003e深圳\u003c/option\u003e \u003coption value=\"gz\"\u003e广州\u003c/option\u003e \u003coption value=\"bj\"\u003e北京\u003c/option\u003e \u003coption value=\"sh\"\u003e上海\u003c/option\u003e \u003c/select\u003e \u003c/p\u003e \u003cp\u003e \u003ctextarea name=\"profile\" cols=\"20\" rows=\"5\" placeholder=\"介绍\"\u003e\u003c/textarea\u003e \u003c/p\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e效果展示： ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:4","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Web"],"content":"超链接标签 超链接： 指向一个目标的连接关系 链接其他文件/网页等： \u003ca href='http://mucunliangtai.com'\u003e \u003c/a\u003e 链接本网页的其他位置：(例：返回顶部) \u003ca href='#id'\u003e \u003c/a\u003e id 为标签的对应 id ，一般需要自己定义。 链接打开新的标签页： \u003ca href = 'http://mucunliangtai.com' target='_blank'\u003e ","date":"2021-09-01","objectID":"/web-%E5%89%8D%E7%AB%AF/:1:5","tags":null,"title":"Web 前端","uri":"/web-%E5%89%8D%E7%AB%AF/"},{"categories":["Python"],"content":"Python扩展_变量 🥪变量 ","date":"2021-08-13","objectID":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/:0:0","tags":null,"title":"Python扩展_变量","uri":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"🧀局部变量 定义： 函数内部定义的变量 def test1(): a = 100 print(a) # 局部变量，仅能在 test1 中使用 def test2(): a = 200 print(a) # a 互不影响 test1() test2() print(a) # 报错，只能在所定义的函数内部使用 ''' 执行结果： 100 200 NameError: name 'a' is not defined '''","date":"2021-08-13","objectID":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/:1:0","tags":null,"title":"Python扩展_变量","uri":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"🌮全局变量 定义： 在文件内有效，能在多个函数内部调用 a = 100 def test3(): print(a) def test4(): print(a) # test3 和 test4都可以调用a test3() test4() ''' 执行结果： 100 100 '''","date":"2021-08-13","objectID":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/:2:0","tags":null,"title":"Python扩展_变量","uri":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"🍖全局变量和局部变量 🍖全局变量和局部变量名字相同时，优先使用最近定义的变量。 有局部变量时，优先使用局部变量；没有局部变量时，看是否有全局变量。 a = 100 def test5(): a = 50 print(a) test5() ''' 执行结果： 50 '''🍖在函数中修改全局变量前，需要在函数中声明变量为 global 被修改的全局变量，在其他函数中访问时数据也会跟着改变。 a = 100 def test1(): global a # 在函数中声明全局变量的关键字：global a = 200 print(\"test1.....\", a) def test2(): print(\"test2中的全局变量：\", a) print(\"全局的：\", a) test1() print(\"test1执行后全局的：\", a) test2() ''' 执行结果： 全局的： 100 test1..... 200 test1执行后全局的： 200 test2中的全局变量： 200 '''🍖可以通过 local() 和 global() 打印局部和全局变量 a = 100 def test1(): a = 200 global b b = 500 print(locals()) # 显示模块（文件）内的局部变量，即为“全局变量” print(globals()) # 不论写在哪里，始终显示的都是全局变量 test1() print(b) ''' 执行结果： {'a': 200} {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': \u003c_frozen_importlib_external.SourceFileLoader object at 0x0000021F204FB550\u003e, '__spec__': None, '__annotations__': {}, '__builtins__': \u003cmodule 'builtins' (built-in)\u003e, '__file__': 'F:/py/test.py', '__cached__': None, 'a': 100, 'test1': \u003cfunction test1 at 0x0000021F204A3EA0\u003e, 'b': 500} 500 '''","date":"2021-08-13","objectID":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/:3:0","tags":null,"title":"Python扩展_变量","uri":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"🥩形式参数和局部变量 def test(a, b): print(f\"局部变量a={a}, b={b}\") a = 10 b.append(\"bbb\") x = 20 y = [\"111\"] print(f\"调用前{x},{y}\") test(x, y) print(f\"调用后{x},{y}\") ''' 执行结果： 调用前20,['111'] 局部变量a=20, b=['111'] 调用后20,['111', 'bbb'] '''对于不可变参数，在函数内，每次都是让局部变量指向新的地址值，所以 a = 10，是局部变量 a 指向了新数值的新地址，不影响外部的 x 。 对于可变参数，在函数内，是传递进来的（原有的）地址值上修改数据内容，所以 b.append(“bbb”),是修改了（和 y 相同的）地址空间的列表内容，所以外部参数内容会受影响。 ","date":"2021-08-13","objectID":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/:4:0","tags":null,"title":"Python扩展_变量","uri":"/python%E6%89%A9%E5%B1%95_%E5%8F%98%E9%87%8F/"},{"categories":["Python"],"content":"Python_面向对象 👰面向对象编程 面向过程： 是以过程为中心的编程思想。 面向对象： 是对象及其之间的交互为中心的编程思想 ","date":"2021-08-12","objectID":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":null,"title":"Python_面向对象","uri":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"👩‍🦰类和对象 class Car: # 定义类: class 类名: energy = \"电动\" # 属性,表示\"特征\" def move(self): # 方法,表示\"行为\" print(\"在移动...\") c = Car() # 对象实例化 : 对象名称 = 类名() print(\"能源类型:\", c.energy) # 访问属性: 对象名称.属性 c.move() # 调用方法: 对象名称.方法类： 具有相同属性和方法的一类事物。(模具 / 图纸…) 对象： 也被称为 “实例”。将类中定义的特征具体化（赋值），就是一个对象或实例。 ","date":"2021-08-12","objectID":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":null,"title":"Python_面向对象","uri":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"👧对象的属性 对象的属性 在类的外部，添加对象属性 在类的内部，添加对象属性 class Dog: def bark(self): print(\"汪汪！\") c = Dog() # 初始化一个对象，就分配一个新的内存空间 c.name = \"cc\" d = Dog() d.name = \"dd\" print(c.name, end=\"\") c.bark() print(d.name, end=\"\") d.bark()","date":"2021-08-12","objectID":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":null,"title":"Python_面向对象","uri":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"🧒魔术方法 定义： 前后用两个下划线包裹，具有特殊功能的方法 魔术方法：__ init __ 方法 class Dog: def __init__(self, name): # 初始化对象时，默认被调用 self.name = name # 成员属性， 每个对象特有的属性(实例属性) print(\"小狗出生了\") c =Dog(\"cc\") # 类属性和成员属性 class Dog: def __init__(self, name): self.name = name self.legs = 4 print(f\"{self.name}出生了\") c = Dog(\"cc\") d = Dog(\"dd\") print(\"legs:\", c.legs) print(\"legs:\", d.legs)","date":"2021-08-12","objectID":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":null,"title":"Python_面向对象","uri":"/python_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["Python"],"content":"Python_集合 set和dict类似，也是一组key的集合，但没有value。key唯一且无序 1. 集合的创建 s1 = set() # 空集合 只能用set() print(s1, type(s1)) s1 = {1, 2, 3} print(s1, type(s1)) ''' 执行结果： set() \u003cclass 'set'\u003e {1, 2, 3} \u003cclass 'set'\u003e '''2. 集合的性质 ","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:0:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"2.1 唯一、无序 # 集合：无序 s1 = {1, 2, 3} s2 = {3, 2, 1} print(s1, type(s1)) # {1, 2, 3} print(s2, type(s2)) # {1, 2, 3} # 集合：唯一 s1 = {1, 1, 2, 3, 3} print(s1) ''' 执行结果： {1, 2, 3} \u003cclass 'set'\u003e {1, 2, 3} \u003cclass 'set'\u003e {1, 2, 3} '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:1:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"2.2 集合存储各种数据类型 # 集合：存放不可变(key) s1 = {1, 2, 3, False, \"4\"} # 字典存放多种数据类型 print(s1) # list1 = [1, 2, 3] # 列表可变 存放报错 # s2 = {1, list1} # print(s2) # dic1 = {1: 2} # 字典可变 存放报错 # s3 = {1, dic1} # print(s3) tuple1 = (1, 2, 3) s3 = {1, tuple1} print(s3) ''' 执行结果： {False, 1, 2, 3, '4'} {1, (1, 2, 3)} '''3. 常用的数据操作 ","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:2:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"3.1 增 s1 = {1, 2, 3} print(s1, id(s1)) s1.add(4) print(s1, id(s1)) # 指定序列，依次加入到集合 s1 = {1, 2, 3} s1.update(\"abc\") print(s1, id(s1)) s1 = {1, 2, 3} list1 = [\"a\", \"b\", \"c\"] s1.update(list1) print(s1, id(s1)) ''' 执行结果： {1, 2, 3} 1833057707624 {1, 2, 3, 4} 1833057707624 {1, 2, 3, 'c', 'a', 'b'} 1833060551816 {1, 2, 3, 'c', 'a', 'b'} 1833057707624 '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:3:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"3.2 删 删 clear remove discard pop s1 = {1, 2, 3} s1.clear() # 清空 print(s1) s1 = {1, 2, 3} s1.remove(1) # 移除元素。移除不存在的元素，报错：keyError。不可给定默认值 # s1.discard(4) # 如果没有找到，不做任何操作 print(s1) s1 = {1, 2, 3} a = s1.pop() # 随机弹出一个元素，每次都不一定相同 print(a) print(s1) ''' 执行结果： set() {2, 3} 1 {2, 3} '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:4:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"3.3 改 改：先删除后增加 s1 = {1, 2, 3} s1.remove(1) s1.add(4) print(s1) ''' 执行结果： {2, 3, 4} '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:5:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"3.4 查 # 遍历 s1 = {1, 2, 3} for i in s1: print(i) # 包含 in not in s1 = {1, 2, 3} res = 1 not in s1 print(res) ''' 执行结果： 1 2 3 False '''4. 集合的运算 ","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:6:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"4.1 交、并、差、补 s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} # 集合的运算交 \u0026 或者 intersection result = s1 \u0026 s2 # result = s1.intersection(s2) print(result) # 集合的运算并 | 或者 union result = s1 | s2 # result = s1.union(s2) print(result) # 集合的运算差 - 或者 difference result = s1 - s2 # result = s1.difference(s2) print(result) # 集合的运算异或集(对称差集) ^ 或者 symmetric_difference result = s1 ^ s2 # result = s1.symmetric_difference(s2) print(result) ''' 执行结果： {3, 4} {1, 2, 3, 4, 5, 6} {1, 2} {1, 2, 5, 6} '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:7:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"4.2 子集 a = {1, 2} b = {1, 2, 3, 4} result = a \u003c= b # result= a.issubset(b) 同a\u003c=b # result= b.issuperset(a) 同a\u003c=b print(result) # 不相交 isdisjoint s1 = {1, 2, 3, 4} s2 = {3, 4, 5, 6} result = s1.isdisjoint(s2) print(result) ''' 执行结果： True False '''5. 应用 ","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:8:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"5.1 列表应用 num = [1, 1, 2, 3, 3] s = set(num) # 注意：顺序可能打乱 res = list(s) print(res) ''' 执行结果： [1, 2, 3] '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:9:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"5.2 冰冻集合 frozenset 强制转化为冰冻集合 一旦创建，不能进行任何修改，只能用于集合运算操作 s = frozenset() print(s, type(s)) s1 = [1, 2, 3] s1 = \"abc\" s2 = frozenset(s1) print(s2, type(s2)) # s2.add(4) # 报错 s3 = frozenset(\"4\") print(s2 \u0026 s3) ''' 执行结果： frozenset() \u003cclass 'frozenset'\u003e frozenset({'b', 'c', 'a'}) \u003cclass 'frozenset'\u003e frozenset() '''","date":"2021-08-11","objectID":"/python_%E9%9B%86%E5%90%88/:10:0","tags":null,"title":"Python_集合","uri":"/python_%E9%9B%86%E5%90%88/"},{"categories":["Python"],"content":"Python_语言特性笔记 来源于 stackoverflow 或 github 中 1. Python 函数参数传递 num = 1 def func1(num): num = 2 func1(num) print(num) # num = 1\rlist = [] def func2(list): list.append(1) func2(list) print(list) # list = [1]在Python中，变量是内存中一个对象的 ‘引用’ ，进入到函数中的引用和外部引用无关。由内存值可以看出，内部id发生了改变，已经不是原来的数据了。 而在 List 当中，此对象是可变的对象，可以在其中修改它的值。 可变对象：list，dict，set 不可变：string，tuple，number num = 1 print(id(num)) # id = 1776386160 def func1(num): print(id(num)) # id = 1776386160 num = 2 print(id(num)) # id = 1776386192 func1(num) print(id(num),num) # id = 17763861602. @staticmethod 和 @classmethod Python 的三种方法：实例方法、静态方法、类方法 class A(): def func(self, num): print(f\"实例方法:{self}\", num) @staticmethod def staticmethod(num): print('静态方法', num) @classmethod def classmethod(cls, num): print(f'类方法:{cls}', num) a = A() a.staticmethod(1) # 静态方法 1 A.staticmethod(1) # 静态方法 1 a.classmethod(1) # 类方法:\u003cclass '__main__.A'\u003e 1 A.classmethod(1) # 类方法:\u003cclass '__main__.A'\u003e 1 a.func(1) # 实例方法:\u003c__main__.A object at 0x00000272151BA048\u003e 1 A.func(1) # 报错静态方法都可以调用 类方法所传递的第一个参数都会改变为 此类 A 实例方法所传递的第一个参数是 实例 a 3. 类变量和实例变量 类变量在所有实例中间共享值 实例变量各自独立 4.下划线 _ 和 __ __func__ : Python 内部名字 _func : 私有方法或属性，但是不是解释器所理解的，也可以和普通方法一样使用，单下划线是告诉程序，这个东西是私有的。 __func: 真正的私有，解释器所理解的，会被理解为 _class__func，若直接调用 __func 则会报错5. 生成器和列表 L = [x*x for x in range(10)] print(L) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] t = (x*x for x in range(10)) print(t) # \u003cgenerator object \u003cgenexpr\u003e at 0x00000225ADAD3308\u003e一个是列表，一个是生成器，所占用内部空间不同 6. *args 和 **kwargs *args 和 **kwargs 称呼无所谓，可变。 *args：未知数量的变量 **kwargs：未知数量的字典形式变量 7. 鸭子类型 8.新式类和旧式类 class A(): def foo1(self): print \"A\" class B(A): def foo2(self): pass class C(A): def foo1(self): print \"C\" class D(B, C): pass d = D() d.foo1() # A依次且深度优先 D –\u003e B –\u003e A C 被 覆盖了。 9. 深浅拷贝 我的csdn 深浅拷贝的文章 import copy a = [1, 2, 3, [4, 5]] b = copy.copy(a) c = copy.deepcopy(a) d = a a.append(6) a[3].append(7) print(a) # [1, 2, 3, [4, 5, 7], 6] print(b) # [1, 2, 3, [4, 5, 7]] print(c) # [1, 2, 3, [4, 5]] print(d) # [1, 2, 3, [4, 5, 7], 6]","date":"2021-08-10","objectID":"/python_%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"Python_算法相关笔记 大学没有好好学习算法，前来修补 此文根据 漫画算法：小灰的算法之旅 魏梦舒 学习记录，后续继续补充学习。 算法概述 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:0:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是算法 在我看来，算法 是根据一系列的 规则 进行简便运算。 例如 ‘高斯算法’：从1加到10000，可以一个一个慢慢来，也可以用等差数列求和。答案是相同的，只是过程有好坏快慢。在计算机领域，衡量算法的重要标准有两个： 时间复杂度 空间复杂度 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"算法的实际应用 理论知识固然容易，但是还是需要结合实际来运用，常用的场景： 数学运算 （加减乘除，最大公约数，最小公倍数….） 查找 （SQL或者爬虫获取数据） 排序 （杂乱数据按照大小排序） 最优决策 （迷宫的最短路线，怎么花工资….） 面试 （当然这个必不可少，面试一问算法就天天写冒泡排序）🤣 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是数据结构 每次提到算法，肯定会涉及到数据结构。 在我看来，数据结构 是一个容器，把多个数据存放的方式。算法相当于把这个容器里的东西怎么整理，怎么拿出来，对此基础上进行操作。 数据结构的组成方式： 线性结构 （数组、链表、栈、队列、哈希表） 树 （代表性的是：二叉树、红黑树、二叉堆） 图 （多对多的关系，较为复杂的数据结构） 等等… （有基础的数据结构变换而来） 数据结构基础 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:3:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"数组和链表 物理结构 内存中实际存在的储存结构 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:4:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是数组 Python中没有 数组 ，用列表可以代替。 Python_列表 笔记不再赘述，只记录觉得加深印象的概念。 数组的每一个元素都有自己的下表，可以顺序读取，或者按照标号读取。 数组在内存中是顺序储存，每一个元素都紧密排列，不能打乱元素的储存顺序。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:4:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是链表 链表类似于一条九节鞭，一个接着一个，中间断了，后续也就一起丢失了。 因为链表不仅存放 自身数据，而且存放下一个数据的位置，所以链表在内存中不是顺序储存，可以打乱顺序，只要有内存空间就可以储存。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:4:2","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"数组和链表的对比 数组的优势：定位快、查找快 链表的优势：插入、删除快 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:4:3","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"栈和队列 逻辑结构，是一种抽象概念，依附于物理结构存在。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是栈 我们把几本书堆的很高，一本一本往上堆，当我们想拿出来的时候，也只能从上面一个一个往外取。 栈：是一种 线性结构，它遵循 先进后出 原则（First In Last Out，简称FILO）。 最早进去的元素位置叫做 栈底，最后进去的元素位置叫做 栈顶。 栈可以由 队列 或 链表 实现。 栈的操作 入栈（push）：把一个元素加入栈中，只允许元素从栈顶一侧放入。 出栈（pop）：把一个元素弹出栈，只允许元素从栈顶一侧弹出。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"什么是队列 排队做核酸，来的时候只能在队伍尾巴排队，离开时都要在检测口离开，不允许插队。 队列：是一种 线性结构，它遵循 先进先出 原则（First In First Out，简称FIFO）。 队列的入口处叫 队尾，队列的出口处叫 队头。 队列可以由 队列 或 链表 实现。 队列的基本操作 入队（enqueue）：把一个元素加入到队列中，只允许放在队尾。 出队（dequeue）：把首个元素从队列中移，只允许队头离开。 Python不涉及队列需要扩容,此次学习不深究。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:2","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"栈和队列的应用 栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。 例如实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。 队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。 例如在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:3","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"双端队列（栈+队列） 两端 都可以 入队 或 出队。 既可以 先进先出，也可以 先进后出。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:4","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"优先队列 优先级高的先出 优先队列不属于 线性数据结构，基于 二叉堆来实现的。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:5:5","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"散列表（哈希表） 这种数据结构提供了 键(key) 和 值(value) 的映射关系。 时间复杂度接近O(1)。 这种数据结构像 字典 一样，说一个汉语，就可以有对应的翻译。 Python 哈希表详细解释Python 哈希表 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:6:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"哈希函数 将哈希表中元素的键 (通常为String类型) 映射为数组下标的函数，获得数组下标后很容易获取数组的值。因为数组的取值是位置顺序，不好分辨。哈希函数就是将 键(字符串) 与值对应起来，方便查询。不同语言，哈希函数实现方式不一样，不深究。 散列表的操作 在Python中，散列表的实现为 字典，字典学习笔记。 哈希冲突 当遇到哈希函数通过不同的键获得相同的位置时，产生冲突。 常用的哈希冲突的解决方法有两种：开放地址法和链地址法。 开放地址法：当遇到冲突时，通过某种方法找到一个空闲位置插入。 链地址法：获得相同位置时，此位置不存数据，而是存数据的集合。 树 树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点。 有且仅有一个特定的称为根的节点。 当n\u003e1时，其余节点可分为m（m\u003e0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 下面这张图，就是一个标准的树结构。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:6:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"二叉树 二叉树是树的一种特殊形式，其孩子节点最多有两个。左边叫左孩子(left child)，右边叫右孩子(right child)。 满二叉树：一个二叉树的所有非叶子节点都存在左右孩子，并且所有孩子在同一层级上。 完全二叉树：满二叉树 的一部分，这一部分必须是按照顺序的。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:7:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"二叉树的物理结构 因为二叉树属于逻辑结构，所需需要一定的物理结构来实现。 链式储存结构 数组 链式储存结构 数组 使用数组存储时，会按照层级顺序把二叉树的节点放到数组中对应的位置上。如果某一个节点的左孩子或右孩子空缺，则数组的相应位置也空出来。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:7:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"二叉树的应用 其最主要应用在于 查找操作 和 维持相对顺序 查找 二叉查找树(二叉排序树)：在原二叉树基础上增加了以下条件： 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 如果右子树不为空，则右子树上所有节点的值均小于根节点的值 左、右子树也都是二叉查找树 后续深究学习… ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:7:2","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"二叉树的遍历 从节点之间位置关系，二叉树的遍历分为四种： 前序遍历：根左右 中序遍历：左根右 后序遍历：左右根 层序遍历 从宏观的角度来看，二叉树的遍历分两类： 深度优先遍历（前序遍历，中序遍历，后序遍历） 广度优先遍历（层序遍历） ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:8:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"二叉堆 二叉堆分为：最大堆 和 最小堆 二叉堆虽然是一个完全二叉树，但是它的存储结构是顺序结构，其所有节点存在数组中。 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:9:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"优先队列 队列：先进先出 优先队列：不在遵循先进先出，分以下两种情况 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:10:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"优先队列的实现 利用二叉堆进行排序： 最大堆或最小堆都可以获取最大元素或最小元素。 排序算法 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:10:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"冒泡排序 # 冒泡排序 # 列表每两个相邻的数，如果前面比后面大，则交换这两个数 # 时间复杂度:O(n2) def bubble_sort(li): for i in range(len(li) - 1): exchange = False for j in range(len(li) - i - 1): if li[j] \u003e li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] exchange = True if not exchange: return","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:11:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"冒泡优化 鸡尾酒排序 冒泡是每次选取最大或者最小的数，n-1次循环。 鸡尾酒进行优化，最大和最小的数依次获取，然后循环。针对于大部分数据有序的数组，整理的速度快一些。 def cocktail_sort(li): size = len(li) sign = True # 标记 for i in range(size//2): if sign: # 判断是否还有可交换的元素 sign = False for j in range(i, size - 1 - i): if li[j] \u003e li[j + 1]: li[j], li[j + 1] = li[j + 1], li[j] for k in range(size - 2 -i , i, -1 ): if li[k] \u003c li[k - 1]: li[k], li[k - 1] = li[k - 1], li[k] sign = True else: return","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:11:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"快速排序 双边循环 # 快排 双边循环 # 递归思想，找到一个基准，所有小的放在基本左边，大的都放在右边，递归后顺序 # 时间复杂度：最坏 n^2（逆序列），在最好 n（logn）。 def _quick_double(li, left, right): start = left pivot = li[start] while left != right: # 左侧只要小于 pivot,大于 pivot放在原位 while left \u003c right and li[right] \u003e pivot: right -= 1 # 右侧只大于 pivot,小于 pivot放在原位 while left \u003c right and li[left] \u003c= pivot: left += 1 li[left], li[right] = li[right], li[left] li[start], li[left] = li[left], li[start] return left def quick_sort_double(li, left, right): if left \u003e= right: return q = _quick_double(li, left, right) quick_sort_double(li, left, q-1) quick_sort_double(li, q+1, right)","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:12:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"快速排序 单边循环 def quick_sort2(li, start, end): if start \u003e= end: return pivot = li[start] right = end left = start # 控制right -= 1不满足条件交换 while left \u003c right: while left \u003c right and li[right] \u003e pivot: right -= 1 li[left] = li[right] # 控制 left += 1 , 不满足条件交换 while left \u003c right and li[left] \u003c pivot: left += 1 li[right] = li[left] # 退出循环 left = right # left 或者 right 对应的位置 赋值为基准值 li[left] = pivot # 递归 quick_sort2(li, start, left - 1) # 对左边排序 quick_sort2(li, left + 1, end) # 对右边排序","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:12:1","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"快速排序 非递归 用栈来实现 待补充😢 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:12:2","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"堆排序 利用最大堆–\u003e从小到大排序 利用最小堆–\u003e从大到小排序 # 以最大堆获取 从小到大的有序排列为例 # 空间复杂度为 O(1) # 时间复杂度为 O(nlogn) def big_heap(li, start, end): # 最大堆 root = start left = start * 2 + 1 while left \u003c= end: # 存在右子节点，且右子节点大于左子节点，则将左子节点变成右子节点的索引 if left + 1 \u003c= end and li[left] \u003c li[left + 1]: left += 1 if li[root] \u003c li[left]: # 把大的放上面 li[root], li[left] = li[left], li[root] # 存在孙节点，继续比较 root = left left = root * 2 + 1 else: break def heap_sort(li): first = len(li) // 2 - 1 for start in range(first, -1, -1): # 倒序调成，循环构建最大堆 big_heap(li, start, len(li) - 1) for end in range(len(li) - 1, 0, -1): # 将堆顶和堆尾交换数据 li[0], li[end] = li[end], li[0] # 重新调成最大堆 big_heap(li, 0, end - 1) return","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:13:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"计数排序 例如从 0-9 生成20个随机数，统计0-9每个的次数，然后依次写下来就是有序的😂 在最大值和最小值相差不大时，用这个排序还是很快的 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:14:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"桶排序 类似计数排序，不过是生成几个区间，然后再对区间内部进行排序，再依次写下所有的桶 ","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:15:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"选择排序 # 先从整个序列中选择最小的数据放到第一位，再从剩余的序列中选择最小的数据放在第二位，如此循环，直到最后一位。 # O(n2) def select_sort_simple(li): li_new = [] for i in range(len(li)): min_val = min(li) li_new.append(min_val) li.remove(min_val) return li_new def select_sort(li): for i in range(len(li)-1): min_loc = i for j in range(i+1, len(li)): if li[j] \u003c li[min_loc]: min_loc = j li[j], li[min_loc] = li[min_loc], li[i]","date":"2021-08-09","objectID":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/:16:0","tags":null,"title":"Python_算法相关笔记","uri":"/python_%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0/"},{"categories":["Python"],"content":"Python_游戏脚本思路及API EVE游戏自动检测喊话 通过图片识别来获取文本，并自动喊话 ","date":"2021-08-08","objectID":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/:0:0","tags":null,"title":"Python_游戏脚本思路及API","uri":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/"},{"categories":["Python"],"content":"获取窗口 代码主要用来获取电脑启动的程序，以程序名字来获取，也可以用来匹配其他窗口应用程序。 def foo(hwnd, mouse): # 获取窗口 global titles if IsWindow(hwnd) and IsWindowEnabled(hwnd) and IsWindowVisible(hwnd): titles.add(GetWindowText(hwnd)) EnumWindows(foo, 0) lt = [t for t in titles if t] lt.sort() for t in lt: if (t.find('MuMu模拟器')) \u003e= 0: hwnd = FindWindow(None, t) print('MuMu模拟器窗口:',hwnd) def play_game(): # 置顶窗口，调整尺寸 global titles EnumWindows(foo, 0) lt = [t for t in titles if t] lt.sort() for t in lt: if(t.find('MuMu模拟器')) \u003e= 0: hwnd = FindWindow(None, t) # print(hwnd) SetWindowPos(hwnd, win32con.HWND_TOP,0,0,1280, 720,win32con.SWP_SHOWWINDOW) # 第二个参数可以调整置顶方式 hwnd=FindWindow(None, t) # print(hwnd) size = GetWindowRect(hwnd) # print(size) return size","date":"2021-08-08","objectID":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/:1:0","tags":null,"title":"Python_游戏脚本思路及API","uri":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/"},{"categories":["Python"],"content":"部分接口 模拟键盘或者鼠标按键操作 # 模拟鼠标点击 def mouse_click(x, y): win32api.SetCursorPos([x, y]) # 移动鼠标位置 win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0) # 返回粘贴板的内容 def getText(): win32clipboard.OpenClipboard() d = win32clipboard.GetClipboardData(win32con.CF_TEXT) win32clipboard.CloseClipboard() return d # 模拟 Ctrl + C def setText(aString): win32clipboard.OpenClipboard() win32clipboard.EmptyClipboard() win32clipboard.SetClipboardData(win32con.CF_TEXT, aString.encode('gbk')) win32clipboard.CloseClipboard() # 模拟 Ctrl + V def ctrlV(): win32api.keybd_event(17,0,0,0) #ctrl win32api.keybd_event(86,0,0,0) #V win32api.keybd_event(86,0,win32con.KEYEVENTF_KEYUP,0)#释放按键 win32api.keybd_event(17,0,win32con.KEYEVENTF_KEYUP,0)","date":"2021-08-08","objectID":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/:2:0","tags":null,"title":"Python_游戏脚本思路及API","uri":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/"},{"categories":["Python"],"content":"OCR识别 此处使用 pytesseract、PIL ，需要安装 pytesseract-OCR，可以在网上找资源，安装后更改 pytesseract.py 文件的最开始的一行代码，需要指定 pytesseract-OCR 的根路径，即可使用。 save_path = 'num.png' x ,x2 = 100+72.5*i, 135 +75*i img = ImageGrab.grab(bbox=(x,310,x2,335)) # 更改尺寸大小，方便识别 img = img.resize((140, 100)) # 图片反转颜色，方便识别 ImageOps.invert(img).save(save_path) # 保存图片 # 识别数字 num = pytesseract.image_to_string(Image.open(save_path),config='--psm 10 --oem 3 -c tessedit_char_whitelist=0123456789')pytesseract.image_to_string(img)，后续的 config 是识别英文、数字、中文之类的参数，此处我也不是很理解，可以识别不清楚时寻找相应的参数即可。 ","date":"2021-08-08","objectID":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/:3:0","tags":null,"title":"Python_游戏脚本思路及API","uri":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/"},{"categories":["Python"],"content":"完整代码 import time import re from win32gui import * import win32con import win32api import win32clipboard from PIL import Image, ImageGrab,ImageOps import os import pytesseract from pynput.keyboard import Key,Controller titles = set() findnum = re.compile(r'\u003c.*\u003e(.*)\u003c/.*\u003e') eveCnf = [] global OCRnum OCRnum = 0 def foo(hwnd, mouse): # 获取窗口 global titles if IsWindow(hwnd) and IsWindowEnabled(hwnd) and IsWindowVisible(hwnd): titles.add(GetWindowText(hwnd)) EnumWindows(foo, 0) lt = [t for t in titles if t] lt.sort() for t in lt: if (t.find('MuMu模拟器')) \u003e= 0: hwnd = FindWindow(None, t) print('MuMu模拟器窗口:',hwnd) def play_game(): # 置顶窗口，调整尺寸 global titles EnumWindows(foo, 0) lt = [t for t in titles if t] lt.sort() for t in lt: if(t.find('MuMu模拟器')) \u003e= 0: hwnd = FindWindow(None, t) # print(hwnd) SetWindowPos(hwnd, win32con.HWND_TOP,0,0,1280, 720,win32con.SWP_SHOWWINDOW) hwnd=FindWindow(None, t) # print(hwnd) size = GetWindowRect(hwnd) # print(size) return size # 模拟鼠标点击 def mouse_click(x, y): win32api.SetCursorPos([x, y]) # 移动鼠标位置 win32api.mouse_event(win32con.MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0) win32api.mouse_event(win32con.MOUSEEVENTF_LEFTUP, 0, 0, 0, 0) # 返回粘贴板的内容 def getText(): win32clipboard.OpenClipboard() d = win32clipboard.GetClipboardData(win32con.CF_TEXT) win32clipboard.CloseClipboard() return d # 模拟 Ctrl + C def setText(aString): win32clipboard.OpenClipboard() win32clipboard.EmptyClipboard() win32clipboard.SetClipboardData(win32con.CF_TEXT, aString.encode('gbk')) win32clipboard.CloseClipboard() # 模拟 Ctrl + V def ctrlV(): win32api.keybd_event(17,0,0,0) #ctrl win32api.keybd_event(86,0,0,0) #V win32api.keybd_event(86,0,win32con.KEYEVENTF_KEYUP,0)#释放按键 win32api.keybd_event(17,0,win32con.KEYEVENTF_KEYUP,0) # 主要文本识别以及具体游戏实现 def game(): size = play_game() numList = [] for i in range(3): save_path = 'num.png' x ,x2 = 100+72.5*i, 135 +75*i img = ImageGrab.grab(bbox=(x,310,x2,335)) img = img.resize((140, 100)) ImageOps.invert(img).save(save_path) num = pytesseract.image_to_string(Image.open(save_path),config='--psm 10 --oem 3 -c tessedit_char_whitelist=0123456789') num = num.split('\\n')[0] numList.append(num) for i in range(len(numList)): for j in numList[i]: if j == 'S': numList[i] = numList[i].replace(\"S\",\"5\") elif j == 'q': numList[i] = numList[i].replace(\"q\", \"9\") elif j == 'l': numList[i] = numList[i].replace(\"l\", \"1\") elif j == 'e': numList[i] = numList[i].replace(\"e\", \"2\") elif j == 'o' or 'O': numList[i] = numList[i].replace(\"o\", \"0\") numList[i] = numList[i].replace(\"O\", \"0\") str4 = eveCnf[2] str3 = str4.replace('x',str(numList[0])) str2 = str3.replace('y',str(numList[1])) str1 = str2.replace('z',str(numList[2])) print(f'第 {OCRnum} 次OCR识别'+str1) try: if int(numList[0]) \u003c eveCnf[1] and int(numList[1]) \u003ceveCnf[1] and int(numList[2]) \u003c eveCnf[1]: print('数值小于'+str(eveCnf[1])+','+str(eveCnf[0])+'s后再次执行') time.sleep(eveCnf[0]) else: setText(str1) mouse_click(265, 550) time.sleep(2) mouse_click(230, 630) time.sleep(2) ctrlV() mouse_click(490, 470) time.sleep(2) mouse_click(480, 630) time.sleep(2) mouse_click(510, 60) time.sleep(eveCnf[0]) except: print('读取数字可能失败，等待1s后再次读取') time.sleep(1) def readCnf(): f = open('./eve.cnf', 'r+') for i in range(3): tmp = f.readline() tmp = re.findall(findnum, tmp)[0] if i == 0 or i == 1: eveCnf.append(int(tmp)) else: eveCnf.append(tmp) f.close() def EVEsize(): # 置顶窗口，调整尺寸 global titles EnumWindows(foo, 0) lt = [t for t in titles if t] lt.sort() for t in lt: if(t.find('\\EVE')) \u003e=0: hwnd = FindWindow(None, t) SetWindowPos(hwnd, win32con.HWND_TOP,1000,300,500, 200,win32con.SWP_SHOWWINDOW) if __name__ == '__main__': readCnf() EVEsize() print('模拟器设置画面亮度为100/普通，本地统计拉至左上角，此脚本不阻挡本地统计') input(\"输入数字 1 并回车则开始预警：\") while True: OCRnum +=1 game()","date":"2021-08-08","objectID":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/:4:0","tags":null,"title":"Python_游戏脚本思路及API","uri":"/python_%E6%B8%B8%E6%88%8F%E8%84%9A%E6%9C%AC%E6%80%9D%E8%B7%AF%E5%8F%8Aapi/"},{"categories":["Python"],"content":"Python_文件操作 📖文件操作 ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"📕文件操作的基本流程 ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"🎇绝对路径和相对路径 绝对路径： 从盘符开始 （\"F:\\study_project\\文件操作\\test.txt\"） 相对路径： 型对于当前源码所在位置 （\"test.txt\"） ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:1","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"🎆编码格式 指定编码格式，无乱码产生 windows 是 GBK ，可以在设置更改 默认打开 pycharm 是 UTF-8 编码，所以可能会有乱码 # 指定编码 f = open(\"test.txt\", \"w\", encoding=\"UTF-8\") f.write(\"你好，世界\") f.close()","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:2","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"📕写(write) 📕单行写入 f = open(\"test.txt\", \"w\") # 不存在文件则新建 f.write(\"hello world\") f.close() # 关闭文件 打开要关闭 避免占内存📕多行写入 # writelines 一次性写入多行 f = open(\"test.txt\", \"w\", encoding=\"UTF-8\") # f.write(\"你好，世界\\n人生苦短\\n我用Python\") content = [\"你好，世界\", \"人生苦短\", \"我用Python\"] f.write(\"\\n\".join(content)) f.close()","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:3","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"📘读(read) 创建一个有 10 行 python 的文件 f = open(\"test2.txt\", \"w\", encoding=\"UTF-8\") f.write(\"Python\\n\" * 10) f.close()读取文件： f = open(\"test2.txt\", \"r\", encoding=\"UTF-8\") data = f.read() print(data) ''' 执行结果： Python Python Python Python Python Python Python Python Python Python '''重新读取文件按照字符读取： f = open(\"test2.txt\", \"r\", encoding=\"UTF-8\") data = f.read(1) # 读取1个字符 print(data) data2 = f.read(2) # 向后继续读2个字符 注：汉字也是一个字符 print(data2) f.close() ''' 执行结果： P yt '''发现第二次读取并不是重新开始读取，而是接着重新打开后读取 1 个字符后的结尾 (指针所在位置) 读取。 📘readline 读一行 读取一行，返回一个字符串 f = open(\"test2.txt\", \"r\", encoding=\"utf-8\") while True: content = f.readline() if content: print(f\"{content}\", end=\"\") else: break f.close() ''' 执行结果： Python Python Python Python Python Python Python Python Python Python '''📘readlines 读多行 f = open(\"test2.txt\", \"r\", encoding=\"utf-8\") content = f.readlines() print(content) i = 1 for data in content: print(f\"{i}:{data}\", end=\"\") i +=1 # 上述代码可用下面的函数enumerate() # for i, data in enumerate(content): # print(f\"{i}:{data}\", end=\"\") f.close() ''' 执行结果： ['Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n', 'Python\\n'] 1:Python 2:Python 3:Python 4:Python 5:Python 6:Python 7:Python 8:Python 9:Python 10:Python '''📘 tell 返回指针当前所在位置(字节) f = open(\"test3.txt\", \"w\", encoding=\"utf-8\") f.write(\"你好，世界\") f.close() f = open(\"test3.txt\", \"r\", encoding=\"utf-8\") content = f.read(2) # read读 字符 print(content) # gbk 中文占2个字节 print(\"当前指针所在位置：\", f.tell()) # utf-8中文占3个字节 f.close() ''' 执行结果： 你好 当前指针所在位置： 6 '''📘seek 定位文件读取的指针所在位置(字节) f.seek(x, y) x : 开始的偏移量，也就是代表需要移动偏移的字节数 y : 可选，默认值为 0。给x参数一个定义，表示要从哪个位置开始偏移；0代表从文件开头开始算起，1代表从当前位置开始算起，2代表从文件末尾算起。 f = open(\"test3.txt\", \"r\", encoding=\"utf-8\") content = f.read(2) print(content) f.seek(4) print(\"当前指针所在位置：\", f.tell()) ''' 执行结果： 你好 当前指针所在位置： 4 '''","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:4","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"📙文件访问模式 ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"🏷访问不存在的文件 当文件不存在，w 和 a 可以新建文件 r 会报错 ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:1","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"✏r+ 可读可写 f = open(\"test4.txt\", \"r+\", encoding=\"utf-8\") data = f.read() f.write(\"我用Python\") f.seek(0) f.write(\" 我用Python\") f.close()","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:2","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"✒二进制文件操作 二进制文件的读写 （图片、音乐、视频等） 将文件的内容单纯的用 0 1 来进行读取 fin = open(\"文件操作.png\", mode=\"rb\") fout = open(\"文件操作_copy.png\", mode=\"wb\") # 方式一 # while True: # data = fin.read(100) # if data: # fout.write(data) # else: # break # 方式二 while True: data = fin.read(100) if data != b\"\": fout.write(data) else: break fin.close() fout.close()","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"🔑缓冲区 写入过程： 数据 –\u003e 缓冲区（内存) –\u003e 文件中（硬盘) flush 刷新缓冲区 ","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"🔑 truncate 截断 # 新建文件test5 f = open(\"test5.txt\", \"w\", encoding=\"utf-8\") f.write(\"Python\"*5) f.close() f = open(\"test5.txt\", \"r+\", encoding=\"utf-8\") f.seek(11) f.truncate() # 从指针位置到结束位置全部删除 # f.truncate(8) 从开始位置到指定位置 保存 f.close()","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:1","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"📝文件对象 可迭代 f = open(\"test2.txt\", \"r\", encoding=\"utf-8\") for line in f: print(line, end=\"\") f.close() f = open(\"test5.txt\", \"r\") print(\"文件名：\", f.name) print(\"文件打开的模式\", f.mode) print(\"文件可写：\", f.writable()) print(\"文件可读：\", f.readable()) ''' 执行结果： Python Python Python Python Python Python Python Python Python Python 文件名： test5.txt 文件打开的模式 r 文件可写： False 文件可读： True '''","date":"2021-08-07","objectID":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:5:0","tags":null,"title":"Python_文件操作","uri":"/python_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Python"],"content":"Python_封装 🚗封装 定义： 对外部隐藏信息，不能随意访问 / 修改对象的数据、方法。通过限制类的属性和方法的访问方式，实现 “封装”。 ","date":"2021-08-06","objectID":"/python_%E5%B0%81%E8%A3%85/:0:0","tags":null,"title":"Python_封装","uri":"/python_%E5%B0%81%E8%A3%85/"},{"categories":["Python"],"content":"🚓封装的层次 封装分为三个层次 类的封装： 外部可以任意访问/修改类中的属性和方法。 私有属性： 外部不可以访问/修改类的属性或方法。 公有方法+私有属性： 外部有条件限制的访问/修改属性，调用方法。 ","date":"2021-08-06","objectID":"/python_%E5%B0%81%E8%A3%85/:1:0","tags":null,"title":"Python_封装","uri":"/python_%E5%B0%81%E8%A3%85/"},{"categories":["Python"],"content":"🚕封装的表现 类的定义： 将某些特定属性和方法进行“隔离”。 （每个学生有自己的年龄，外部可以通过对象任意读取或修改） class Student: def __init__(self, name, age): self.name = name self.age = age s1 = Student(\"李白\", 18) s2 = Student(\"杜甫\", 20) print(s1.age) s1.age = 200 # 可随意更改 print(s1.age) ''' 执行结果: 18 200 '''属性私有： 两个下划线开头的属性就是私有属性。私有属性只能在类的内部使用，外部不能使用。 （不让外部读取/修改学生的年龄） class Student: def __init__(self, name, age): self.name = name self.__age = age # 使用2个下划线开头的属性，定义为私有属性 s1 = Student(\"李白\", 18) # print(s1.__age) # 外界无法直接通过属性名来访问 # __dict__ print(s1.__dict__) # 查看s1的所有属性 print(s1._Student__age) # 可通过_Student__age 访问私有属性 ''' 执行结果： {'name': '李白', '_Student__age': 18} 18 '''私有属性+共有方法： 可以实现“有限制条件的开放给外部”。 （可以读取年龄，但是不能随意修改年龄） class Student: def __init__(self, name, age): self.name = name self.__age = age def getAge(self): return self.__age def setAge(self, age): if 0 \u003c age \u003c=130: self.__age = age else: print(\"不能随意修改\") s1 = Student(\"李白\", 18) print(s1.getAge()) s1.setAge(200) print(s1.getAge()) ''' 执行结果： 18 不能随意修改 18 '''","date":"2021-08-06","objectID":"/python_%E5%B0%81%E8%A3%85/:2:0","tags":null,"title":"Python_封装","uri":"/python_%E5%B0%81%E8%A3%85/"},{"categories":["Python"],"content":"🛺封装的简化(常用)写法 装饰器的概念： 以 @ 开头，调用另一个函数（或方法），扩展对“所修饰方法”的功能。 @property 装饰器修饰的属性用来返回属性值；还可以继续进行 setter 的设置，用来设置属性值。 class Dog: @property def bark(self): print(\"汪汪\") return \"return值\" d = Dog() s = d.bark print(s) ''' 执行结果： 汪汪 return值 '''简化 Student class Student: def __init__(self, name, age): self.name = name self.__age = age @property def age(self): return self.__age @age.setter def age(self, age): if 0 \u003c age \u003c=130: self.__age = age else: print(\"不能随意修改\") s1 = Student(\"李白\", 18) print(s1.age) s1.age = 20 print(s1.age) ''' 执行结果： 18 20 '''🚎总结 使用 @property 装饰器时，方法名不必与属性名相同。 可以更好地防止外部通过猜测里有属性名访问。 凡是赋值语句，就会触发 set 方法。获取属性值，则会触发 get 方法。 扩展： # 私有方法，可以在类内部使用 # 可以有条件的开放给外部 class Student: def talk(self, identity): if identity == \"铁子\": self.__tellSecrect() else: print(\"speak...\") def __tellSecrect(self): print(\"...\") s = Student() s.talk(\"铁子\") ''' 执行结果： ... '''","date":"2021-08-06","objectID":"/python_%E5%B0%81%E8%A3%85/:3:0","tags":null,"title":"Python_封装","uri":"/python_%E5%B0%81%E8%A3%85/"},{"categories":["Python"],"content":"Python_字符串 1. 字符串String # python中没有字符类型，一个字符也是字符串类型 # UTF-8编码 所有字符串都是unicode字符串 # 单引号 双引号 三引号 word = 'String' sentence = \"this is sentence\" paragraph = \"\"\" more this is paragraph \"\"\"2. 转义字符 my_str = \"i'm a student\" my_str1 = 'i\\'m a student' my_str2 = r'i\\'m a student' # 转义不生效 print(my_str) print(my_str1) print(my_str2) ''' 执行结果： i'm a student i'm a student i\\'m a student '''3. 字符串切片（字符串的截取） str1 = \"student\" # 正索引 0123456 # 负索引-7....-1 print(len(str1)) # 内置函数len() 获取长度 print(str1[2:6]) # 截取 print(str1[2:6:2]) # 左闭，右开，间隔步长 print(str1[::-1]) # 倒着打印 ''' 执行结果： 14 ncun nu iatgnailnucnum '''4. 字符串的拼接 str1 = \"student\" str1 += \"study\" print(str1) print('*' * 30) str2 = \"tooooooooooooooooooo\"\\ \"long\"\\ \"write\" print(str2) ''' 执行结果： studentstudy ****************************** tooooooooooooooooooolongwrite '''5. String 常用函数 ","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.1 字母转换 # capitalize 首字母大写 str1 = \"student\" res = str1.capitalize() print(res) # title 每个单词的首字母大写 str1 = \"student and teacher \" res = str1.title() print(res) res = str1.istitle() #判断是否每个单词首字母大写 print(res) # upper 全大写 # str1.upper() # lower 全小写 # str1.lower() # swapcase 大小写互换 # str1.swapcase() ''' 执行结果： Student Student And Teacher False '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.2 统计和查找 # count 统计字符串中某个元素的数量 str1 = \"Students\" res = str1.count(\"S\") #区分大小写，可为字符串 print(res) # find 查找某个字符第一次出现的位置 # find(\"字符串\"，开始位置，结束位置) 结束位置取不到，取到之前的一个值。取不到为-1 # index 与 find 功能相同。find找不到返回-1，而index取不到会报错。 ''' 执行结果： 1 '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.3 判断开头、结尾 # startswith 判断是否以某个字符或字符串为开头 # startswith('字符串'，开始位置，结束位置) 返回为True或False # endswith 判断是否以某个字符或字符串为结尾 # endswith('字符串'，开始位置，结束位置) 返回为True或False","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.4 分割与拼接 # split 按某字符将字符串分割成 列表(默认从左到右按空格分隔) # split(\"字符串\", 切割个数) str1 = \"我_是_憨_憨\" res = str1.split(\"_\", 1) print(res) # rsplit 从右往左排列 注意前面有r # join 按某字符将列表拼接成字符串(容器类型都可) list1 = [\"st\", \"ud\", \"ent\"] res = \"-\".join(list1) print(res) ''' 执行结果： ['我', '是_憨_憨'] st-ud-ent '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.5去掉与替换 # replace 替换字符串(第三个参数选择替换的次数) str1 = \"student\" res = str1.replace(\"stu\",\"aaa\") print(res) res = str1.replace(\"t\", \"a\", 1) print(res) # strip 默认去掉首位两边的空白符 str1 = \"\\r student \\t \\n\" print(str1) res = str1.strip() print(res) # lstrip() 只去掉左侧空白符 # rstrip() 只去掉右侧空白符 ''' 执行结果： aaadent saudent student student '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:5:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.6 判断类型 # isspace() 字符串中只包含空白 返回True 否则返回False res = \" \" print(res.isspace()) # isalpha() 字符串是否为纯字母 res = \"abc1\" print(res.isalpha()) res = \"abc\" print(res.isalpha()) res = \"#a\" print(res.isalpha()) # isalnum() 字符串至少一个字符，所有字符都有字母或者数字 res = \"a\" print(res.isalnum()) res = \"1.1\" print(res.isalnum()) res = \"1\" print(res.isalnum()) # isdecimal 检测字符串是否以数字组成，必须是纯数字 # isdigit() 字符串只包含数字则返回True，否则返回False # isnumeric() 字符串只包含数字字符，返回True，否则返回False # 差别在 汉字数字 罗马数字 byte数字 ''' 执行结果： True False True False True False True '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:6:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.7 长度、填充 str1 = \"student\" # len()计算长度 print(len(str1)) # center 填充字符串，原字符居中(默认空格填充) res = str1.center(10, \"*\") print(res) ''' 执行结果： 7 *student** '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:7:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"5.8 编码和解码 # max 返回字符串编码最大的字母 # min 返回字符串编码最小的字母 # ord 内置函数，返回汉字或字母的Unicode编码 # chr 内置函数，给定Unicode编码 返回字符串 str1 = \"学生\" str_utf8 = str1.encode(\"UTF-8\") str_gbk = str1.encode(\"GBK\") print(f\"URF-8编码：{str_utf8}\") print(f\"GBK编码：{str_gbk}\") print(f\"URF-8解码：{str_utf8.decode('UTF-8')}\") print(f\"GBK解码：{str_gbk.decode('GBK')}\") ''' 执行结果： URF-8编码：b'\\xe5\\xad\\xa6\\xe7\\x94\\x9f' GBK编码：b'\\xd1\\xa7\\xc9\\xfa' URF-8解码：学生 GBK解码：学生 '''","date":"2021-08-05","objectID":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/:8:0","tags":null,"title":"Python_字符串","uri":"/python_%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Python"],"content":"Python_字典 dictionary 无序的对象集合 使用 (key-value) 储存，极快的查找速度 key 必须使用 不可变类型 且 唯一性 1. 字典的访问 info = {} # 定义一个空字典 info = {\"name\": \"student\", \"age\": 22} print(info, type(info)) print(info[\"age\"]) # print(info[\"sex\"]) # 访问不存在的key，会报错：keyError print(info.get(\"sex\")) # get方法返回不存在的值，默认返回：None print(info.get(\"sex\", \"男\")) # get方法可以设定默认值，只在找不到时，生效 ''' 执行结果： {'name': 'student', 'age': 22} \u003cclass 'dict'\u003e 22 None 男 '''2. 使用列表创建字典 fromkeys namelist = [\"black\", \"red\", \"white\"] dic1 = {}.fromkeys(namelist) # 以列表中的元素为key, 创建字典 默认value为None dic1 = {}.fromkeys(namelist, \"默认值\") # 默认值可修改 print(dic1) ''' 执行结果： {'black': '默认值', 'red': '默认值', 'white': '默认值'} '''3. 常用的数据操作 ","date":"2021-08-04","objectID":"/python_%E5%AD%97%E5%85%B8/:0:0","tags":null,"title":"Python_字典","uri":"/python_%E5%AD%97%E5%85%B8/"},{"categories":["Python"],"content":"3.1 增 info = {\"name\": \"student\", \"age\": 22} newSex = input(\"请输入性别：\") info[\"sex\"] = newSex print(info) ''' 执行结果： 请输入性别：男 {'name': 'student', 'age': 22, 'sex': '男'} '''","date":"2021-08-04","objectID":"/python_%E5%AD%97%E5%85%B8/:1:0","tags":null,"title":"Python_字典","uri":"/python_%E5%AD%97%E5%85%B8/"},{"categories":["Python"],"content":"3.2 删 info = {\"name\": \"student\", \"age\": 22} del info[\"age\"] # 删除元素 print(info) # info = {\"name\": \"student\", \"age\": 22} # del info # 删除字典 # print(info) # 不存在 info = {\"name\": \"student\", \"age\": 22} info.clear() # 清空 print(info) # pop() info = {\"name\": \"student\", \"age\": 22} name1 = info.pop(\"name\") # 要指定key。 返回删除key对应的value # info.pop(\"sex\") # 删除一个不存在的key, 会报错：keyError # info.pop(\"sex\", \"男\") # 可以给定默认值 print(name1) print(info) # popitem() # 删除最后一个键值对，返回的是：元组类型 info = {\"name\": \"student\", \"age\": 22} res = info.popitem() print(res) res = info.popitem() print(res) ''' 执行结果： {'name': 'student'} {} student {'age': 22} ('age', 22) ('name', 'student') '''","date":"2021-08-04","objectID":"/python_%E5%AD%97%E5%85%B8/:2:0","tags":null,"title":"Python_字典","uri":"/python_%E5%AD%97%E5%85%B8/"},{"categories":["Python"],"content":"3.3 改 info = {\"name\": \"student\", \"age\": 22} info[\"name\"] = \"black\" print(info) info = {\"name\": \"student\", \"age\": 22} info.update({\"sex\": \"男\", \"age\": 18}) # 指定的键存在，更新。指定的键不存在，新增 # info.update(sex=\"男\",age=18) # 另一种写法， 赋值 print(info) ''' 执行结果： {'name': 'black', 'age': 22} {'name': 'student', 'age': 18, 'sex': '男'} '''","date":"2021-08-04","objectID":"/python_%E5%AD%97%E5%85%B8/:3:0","tags":null,"title":"Python_字典","uri":"/python_%E5%AD%97%E5%85%B8/"},{"categories":["Python"],"content":"3.4 查 info = {\"name\": \"student\", \"age\": 22} # for i in info: # 拿到的是键 # print(i) print(info.keys(), type(info.keys())) # 得到所有的键(可迭代对象) 理解为：列表 print(info.values(), type(info.values())) # 得到所有的值(可迭代对象) 理解为：列表 print(info.items(), type(info.items())) # 得到所有的键和值(可迭代对象) 理解为：元组 # 遍历所有的键 for key in info.keys(): print(key) # 遍历所有的值 for value in info.values(): print(value) # 遍历所有的键和值 for key, value in info.items(): print(f\"key={key}, value={value}\") ''' 执行结果： dict_keys(['name', 'age']) \u003cclass 'dict_keys'\u003e dict_values(['student', 22]) \u003cclass 'dict_values'\u003e dict_items([('name', 'student'), ('age', 22)]) \u003cclass 'dict_items'\u003e name age student 22 key=name, value=student key=age, value=22 '''4. 扩展 使用函数，同时得到列表的下标和元素内容 list1 = [\"a\", \"b\", \"c\", \"d\"] # print(type(enumerate(mylist))) for i, x in enumerate(list1): print(i+1, x) ''' 执行结果： 1 a 2 b 3 c 4 d '''","date":"2021-08-04","objectID":"/python_%E5%AD%97%E5%85%B8/:4:0","tags":null,"title":"Python_字典","uri":"/python_%E5%AD%97%E5%85%B8/"},{"categories":["Python"],"content":"Python扩展_递归 ⭐递归 形式： 自己调用自己的函数 递： 递进 归： 返回 ","date":"2021-08-04","objectID":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/:0:0","tags":null,"title":"Python扩展_递归","uri":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/"},{"categories":["Python"],"content":"🚩递归的写法 编写函数（功能） 确定结束条件和返回值 调用函数自身，修改参数 def printNum(n): print(n) if n == 1: return printNum(n - 1) # 调用自身的函数 printNum(100) ''' 执行结果： 100 99 ... 2 1 '''","date":"2021-08-04","objectID":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/:1:0","tags":null,"title":"Python扩展_递归","uri":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/"},{"categories":["Python"],"content":"❤经典例子 ","date":"2021-08-04","objectID":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/:2:0","tags":null,"title":"Python扩展_递归","uri":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/"},{"categories":["Python"],"content":"🧡求指定位数的阶乘 阶乘：n！ = n * (n - 1 )! 分析： f(1) = 1 n = 1 f(n) = f(n-1) * n n\u003e1 def function(a): if a == 1: return 1 return function(a - 1) * a print(function(3)) ''' 执行结果： 6 '''","date":"2021-08-04","objectID":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/:2:1","tags":null,"title":"Python扩展_递归","uri":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/"},{"categories":["Python"],"content":"💛斐波那契数列 斐波那契数列：0，1，1，2，3，5，8，13，21，34，55，89，144… 分析： f(n) = n-1 n\u003c=2 f(n) = f(n-1) + f(n-2) n\u003e2 def function2(n): if n \u003c= 2: return n - 1 return function2(n-1) + function2(n-2) print(function2(10)) ''' 执行结果： 34 '''","date":"2021-08-04","objectID":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/:2:2","tags":null,"title":"Python扩展_递归","uri":"/python%E6%89%A9%E5%B1%95_%E9%80%92%E5%BD%92/"},{"categories":["Python"],"content":"Python_列表 列表、元组、字典、集合，都是常用的容器类型 容器类型，就是用来在内存中保存数据的。 1. 列表的创建与元素的访问 # 方法一：直接赋值 namelist = [] # 定义一个空的列表 print(type(namelist)) namelist = [\"11\", \"11\", 11, True, \"aa\"] # 存放多种数据类型，可重复 print(namelist) print(namelist[1]) # 通过索引访问列表的每个元素 # 字符串和列表都属于序列的概念，所以很多方法都是类似的 # 列表的切片，可以参考字符串的相关操作 namelist = [\"11\", \"11\", 11, True, \"aa\"] print(namelist[1:-1:2]) # [1,-1) 步长为2 可参考字符串 ''' 执行结果： \u003cclass 'list'\u003e ['11', '11', 11, True, 'aa'] 11 ['11', True] '''\r# 方法二：通过list()方法创建或强制类型转化为列表 str() int() a = list() # 创建空的列表对象 print(a) a = list(\"student\") # 创建可迭代的列表对象 print(a) a = list(range(10)) print(a) ''' 执行结果： [] ['s', 't', 'u', 'd', 'e', 'n', 't'] [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] '''\r# 方法三：通过列表推导式创建列表 a = [x*2 for x in range(5)] print(a) ''' 执行结果： [0, 2, 4, 6, 8] '''2. 常用操作 len() max() min() sum() ","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:0:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"2.1 列表的循环遍历 namelist = [\"11\", 11, True, \"aa\"] for name in namelist: print(name) i = 0 while i \u003clen(namelist): print(namelist[i]) i +=1 ''' 执行结果： 11 11 True aa 11 11 True aa '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:1:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"2.2 max()和 min() 获取列表中最大的或者最小的元素 list1 = [False, 2.0, 30, \"a\"] # 字符串和数值无法比较 list1 = [1,2,3,4,5] print(max(list1)) print(min(list1)) #相等比较取前者 ''' 执行结果： 5 1 '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:2:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"2.3 sum() 对全部为数值的元素的列表求和 list1 = [1,2,3,4,5] print(sum(list1)) ''' 执行结果： 15 '''3.常用的数据操作 基本的数据操作：增删改查 ","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:3:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"3.1 增 # append 追加 namelist = [\"11\", \"11\", 11, True, \"aa\"] print(\"增加前的数据\".center(30, \"-\")) for name in namelist: print(name,end=\",\") temp = input(\"\\n追加数据为：\") namelist.append(temp) # 在末尾追加一个元素 print(\"增加后的数据\".center(30, \"-\")) for name in namelist: print(name, end=\",\") ''' 执行结果： ------------增加前的数据------------ 11,11,11,True,aa, 追加数据为：33 ------------增加后的数据------------ 11,11,11,True,aa,33, '''\r# extend 扩展 a = [1, 2] b = [3, 4] a.append(b) # 将b列表当作一个元素增加到a列表中 print(a) a.extend(b) # 将b列表中的每个元素拿出来增加到a列表中 print(a) ''' 执行结果： [1, 2, [3, 4]] [1, 2, [3, 4], 3, 4] '''\r# + 操作 a = [1, 2] b = [3, 4] a = a + b # 生成新的列表 print(a) # 占用空间要大于extend # * 操作 a = [1, 2] b = a * 3 print(b) # insert 插入 a = [1, 2] a.insert(3, 1) print(a) ''' 执行结果： [1, 2, 3, 4] [1, 2, 1, 2, 1, 2] [1, 2, 1] '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:4:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"3.2 删除 del pop remove namelist = [\"11\", \"11\", 11, True, \"aa\"] del namelist[0] # 在指定位置删除一个元素，没有返回值 name = namelist.pop() # 弹出最后一个元素，有返回值（弹出元素） print(name) name = namelist.pop(-2) # 弹出最后指定位置元素，有返回值（弹出元素） print(name) namelist.remove(\"11\") # 删除指定元素，如果匹配到多个，则删除第一个。 无匹配则报错 print(namelist) ''' 执行结果： aa 11 [True] '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:5:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"3.3 改 namelist = [\"11\", \"11\", 11, True, \"aa\"] print(\"原内容\".center(30, \"-\")) print(namelist) print(\"修改内容\".center(30, \"-\")) namelist[0] = 22 print(namelist) ''' 执行结果： -------------原内容-------------- ['11', '11', 11, True, 'aa'] -------------修改内容------------- [22, '11', 11, True, 'aa'] '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:6:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"3.4 查 # in not in find = input(\"请输出你想找的内容:\") namelist = [\"11\", \"11\", 11, True, \"aa\"] if find in namelist: print(\"在\") else: print(\"不在\") ''' 执行结果： 请输出你想找的内容:aa 在 '''\r# index namelist = [\"11\", \"11\", 11, True, \"aa\"] print(namelist.index(11, 0, 3)) # 查[0,3)范围内指定元素, 返回对应下标.找不到会报错 # count namelist = [\"11\", \"11\", 11, True, \"aa\"] print(namelist.count(11)) # 统计某个元素出现的次数 ''' 执行结果： 2 1 '''\r# 排序和反转 a = [1, 4, 2, 3] print(a, id(a)) a.reverse() # 所有元素反转 print(a, id(a)) # a的内存地址没有改变 a.sort() # 所有元素升序排序 print(a, id(a)) # a的内存地址没有改变 a.sort(reverse=True) # 所有元素降序排序 ''' 执行结果： [1, 4, 2, 3] 1299297293384 [3, 2, 4, 1] 1299297293384 [1, 2, 3, 4] 1299297293384 '''4. 列表的嵌套(二维,三位列表….) namelist = [] print(len(namelist)) # 0 namelist = [[], [], []] print(len(namelist)) # 3 print(namelist[0]) # 取列表第一个元素 ''' 执行结果： 0 3 [] '''","date":"2021-08-03","objectID":"/python_%E5%88%97%E8%A1%A8/:7:0","tags":null,"title":"Python_列表","uri":"/python_%E5%88%97%E8%A1%A8/"},{"categories":["Python"],"content":"Python_函数进阶 1. 函数的定义 def func(): # 见名知意 pass # 占位 # 函数的调用 func() print(id(func()), type(func)) ''' 执行结果： 1879014704 \u003cclass 'function'\u003e '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:0:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"1.1 函数名也可以作为变量进行赋值\\传递\\储存 def func1(): print(\"func1\") def func2(): print(\"func2\") res = func1 print(id(res), id(func1)) res() myfuncs = [func1, func2] for i in myfuncs: i() ''' 执行结果： 2087062875808 2087062875808 func1 func1 func2 '''2. 参数 ","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:1:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.1 【位置参数】普通参数 def printInfo(a, b): print(a, b) printInfo(10, 20) ''' 执行结果： 10 20 '''printInfo(10, 20, 30) # 使用位置参数时，数量要一致，否则报错 ","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:2:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.2 【默认参数】有默认值 形式参数 在 默认参数 前 def printInfo(name, age=18): print(f\"name:{name}, age:{age}\") printInfo(\"张三\", 20) printInfo(\"李四\") # 没有给定实际参数时，会给定默认值 ''' 执行结果： name:张三, age:20 name:李四, age:18 '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:3:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.2 【指定参数名复制】 函数调用时，根据参数名，进行针对性赋值 def printInfo(name=\"张三\", age=18): print(f\"name:{name}, age:{age}\") printInfo(age=20, name=\"李四\") # 指定形参变量名， 可以不按照位置顺序传递参数 printInfo(\"李四\", age=20) ''' 执行结果： name:李四, age:20 name:李四, age:20 ''' printInfo(age = 20, \"李四\") # 如果混用， 位置实参 在 关键字实参 前面","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:4:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.3 可变参数 *args : arguments 可变参数 ***kwargs👎 : keyword arguments 关键字参数 * 和 ** 将多个变量进行\"打包\"，变为元组或字典 def printInfo(name, age, *args): print(f\"name:{name}, age:{age}\") print(args, type(args)) printInfo(\"张三\", 18, 22, \"憨憨\") def printInfo(name, age, **kwargs): print(f\"name:{name}, age:{age}\") print(kwargs, type(kwargs)) printInfo(\"张三\", 18, city=\"Beijing\", sex=\"man\") ''' 执行结果： name:张三, age:18 (22, '憨憨') \u003cclass 'tuple'\u003e name:张三, age:18 {'city': 'Beijing', 'sex': 'man'} \u003cclass 'dict'\u003e '''在'函数调用'时，*和**的作用是：'解包' 符号 * 将传进来的字符串、元组、列表、集合转化为多个标准参数 符号 ** 将传进来的字典，转化为多个关键字参数 def printInfo(name, age, *args): print(f\"name:{name}, age:{age}\") print(args, type(args)) rate = [8, 9, 10] rate = (8, 9, 10) rate = {8, 9, 10} # 无序 printInfo(\"张三\", 18, *rate) def printInfo(name, age, **kwargs): print(f\"name:{name}, age:{age}\") print(kwargs, type(kwargs)) info = {\"city\": \"Beijing\", \"sex\": \"man\"} printInfo(\"张三\", 18, **info) ''' 执行结果： name:张三, age:18 (8, 9, 10) \u003cclass 'tuple'\u003e name:张三, age:18 {'city': 'Beijing', 'sex': 'man'} \u003cclass 'dict'\u003e '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:5:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.4 函数的调用顺序 函数调用时，参数传递的顺序: 调用时—\u003e 实际参数，位置参数，关键字参数 顺序： args , *args, **kwargs def testArgs(a, b, c=10, d=20, *args, **kwargs): print(f\"a={a},b={b},c={c},d={d},args={args},kwargs={kwargs}\") testArgs(1, 2, 3, 4, 5, 6, 7, x=100, y=200) def testArgs(*args, a, b, c=10, d=20, **kwargs): # 可变参数在最前面时，匹配到关键字赋值的其他实际参数 print(f\"a={a},b={b},c={c},d={d},args={args},kwargs={kwargs}\") testArgs(1, 2, 3, 4, 5, a=6, c=100, b=7, x=100, y=200) ''' 执行结果： a=1,b=2,c=3,d=4,args=(5, 6, 7),kwargs={'x': 100, 'y': 200} a=6,b=7,c=100,d=20,args=(1, 2, 3, 4, 5),kwargs={'x': 100, 'y': 200} '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:6:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"2.5 命名关键字参数 *后面的参数，被称为‘命名关键字参数’ def testStar(a, b, c, *, name, age): print(f\"a={a},b={b},c={c},name={name},age={age}\") testStar(1, 2, 3, name=\"张三\", age=30) # *的作用，表示*后面的参数必须使用命名的方式来进行参数赋值 ''' 执行结果： a=1,b=2,c=3,name=张三,age=30 '''3 返回值 ","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:7:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"3.1 单返回值 def test(): pass # return 可返回所有类型 res = test() print(res, type(res)) ''' 执行结果: None \u003cclass 'NoneType'\u003e '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:8:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"3.2 多个返回值 将多个返回值，封装在列表，字典，元组容器中。(set会改变顺序) def divid(a, b): return [a, b] def divid2(a, b, c): return a, b, b # 返回元组 res = divid2(1, 2, 3) print(res) ''' 执行结果： (1, 2, 2) '''","date":"2021-08-02","objectID":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/:9:0","tags":null,"title":"Python_函数进阶","uri":"/python_%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"Python_元组 Tuple(元组) 内容不可变，但是包含可变对象 相像列表list 1. 创建元组 tup1 = () # 创建空元组 print(tup1, type(tup1)) ''' 执行结果： () \u003cclass 'tuple'\u003e ''' tup1 = (50) tup2 = (50,) # 元组的必备条件为 , 单元素最后,不可省。 多元素可省略 print(tup1, type(tup1)) print(tup2, type(tup2)) ''' 执行结果： 50 \u003cclass 'int'\u003e (50,) \u003cclass 'tuple'\u003e ''' tup1 = 50, 60, 70 tup2 = 50, print(tup1, type(tup1)) print(tup2, type(tup2)) # 创建元组可以不加() 不推荐 ''' 执行结果： (50, 60, 70) \u003cclass 'tuple'\u003e (50,) \u003cclass 'tuple'\u003e '''2. 常用的数据操作 ","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:0:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"2.1 增(连接) tup1 = (1, 2, 3) tup2 = (4, 5, 6) tup = tup1 + tup2 print(tup, type(tup)) ''' 执行结果： (1, 2, 3, 4, 5, 6) \u003cclass 'tuple'\u003e '''","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:1:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"2.2 删(删除元组对象，不可删内部元素) tup1 = (1, 2, 3) print(tup1) del tup1 print(tup1) # 报错，因为已经删除","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:2:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"2.3 改 (只能更改内部可变变量) list1 = [2, 3] tup1 = (1, list1) print(tup1) list1.append(4) print(tup1) ''' 执行结果： (1, [2, 3]) (1, [2, 3, 4]) '''","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:3:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"2.4 查 tup1 = (1, 2, 3) print(tup1[0]) # 根据下标访问 print(tup1[::-1]) # 切片 ''' 执行结果： 1 (3, 2, 1) '''3. 常用操作 ","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:4:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"3.1 循环 tup1 = (1, 2, 3) for i in tup1: print(i) ''' 执行结果： 1 2 3 '''","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:5:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"3.2 in not in tup1 = (1, 2, 3) if 3 in tup1: print(\"true\") else: print(\"false\") ''' 执行结果: true '''","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:6:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"3.3 计数 计数 count 最大最小max min 求和 sum 长度 len 类比List ","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:7:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"3.4 强制类型转换 tuple() # 字符串 s = \"student\" tup = tuple(s) print(tup, type(tup)) # 列表 list1 = [1, 2, 3] tup = tuple(list1) print(tup, type(tup)) # 生成器对象 (后期详细补充) s = (i*2 for i in range(5)) print(tuple(s)) ''' 执行结果： ('s', 't', 'u', 'd', 'e', 'n', 't') \u003cclass 'tuple'\u003e (1, 2, 3) \u003cclass 'tuple'\u003e (0, 2, 4, 6, 8) '''4. 补充 list1 = [2, 3] tup1 = (1, list1) print(tup1) list1 = [2, 3, 4] print(tup1) ''' 执行结果： (1, [2, 3]) (1, [2, 3]) '''列表更改，但是元组还是[1, [2, 3]]。 tup1保存了list1的地址，第二次访问仍然可以通过地址访问到之前的列表内容。list1第二次赋值，仅仅改变了list1自身指向的内存空间，没有改变tup1已经保存的list1之前的地址 ","date":"2021-08-01","objectID":"/python_%E5%85%83%E7%BB%84/:8:0","tags":null,"title":"Python_元组","uri":"/python_%E5%85%83%E7%BB%84/"},{"categories":["Python"],"content":"Python_函数基础 1. 定义一个函数 def printInfo(): print(\"-\" * 20) print(\"人生苦短，我学Python\") print(\"-\" * 20)","date":"2021-02-24","objectID":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:0:0","tags":null,"title":"Python_函数基础","uri":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"1.1 函数的调用 printInfo() ''' 执行结果： -------------------- 人生苦短，我学Python -------------------- '''","date":"2021-02-24","objectID":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"Python_函数基础","uri":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"1.2 带参数的函数 a, b 为‘形参’ def add2Num(a, b): c = a + b print(c)调用时，给定的数值为实参 add2Num(10, 20) ''' 执行结果： 30 '''","date":"2021-02-24","objectID":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"Python_函数基础","uri":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"},{"categories":["Python"],"content":"1.3 带返回值的函数 def add2Num2(a, b): return a + b result = add2Num2(100, 30) print(result) ''' 执行结果： 130 '''return “返回\"了结果, return结束了函数的执行 def subtraction(a, b): if a \u003c b: return b - a print(\"return 没有结束\") else: return a - b print(\"return 没有结束\") print(\"return 没有结束\") print(subtraction(3, 5)) ''' 执行结果： 2 '''2. 函数(调用)的嵌套 def add2Num3(a, b): return a + b def add3num(a, b, c): return add2Num3(add2Num3(a, b), c) print(add3num(1, 2, 3)) ''' 执行结果： 6 '''","date":"2021-02-24","objectID":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"Python_函数基础","uri":"/python_%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/"}]